/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/owlelia/dist/vo.js
var require_vo = __commonJS({
  "node_modules/owlelia/dist/vo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimitiveValueObject = exports.ValueObject = exports.AbstractValueObject = void 0;
    var deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
    var AbstractValueObject = class {
      constructor(_value) {
        this._value = Object.freeze(_value);
      }
      equals(vo) {
        return vo == null ? false : deepEqual(this._value, vo._value);
      }
    };
    exports.AbstractValueObject = AbstractValueObject;
    var ValueObject3 = class extends AbstractValueObject {
    };
    exports.ValueObject = ValueObject3;
    var PrimitiveValueObject = class extends AbstractValueObject {
      unwrap() {
        return this._value;
      }
    };
    exports.PrimitiveValueObject = PrimitiveValueObject;
  }
});

// node_modules/owlelia/dist/error.js
var require_error = __commonJS({
  "node_modules/owlelia/dist/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var BaseError4 = class extends Error {
      constructor(message) {
        super(message);
        this.name = new.target.name;
      }
      to(clazz) {
        return new clazz(this.message);
      }
    };
    exports.BaseError = BaseError4;
  }
});

// node_modules/owlelia/dist/entity.js
var require_entity = __commonJS({
  "node_modules/owlelia/dist/entity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Entity = void 0;
    var Entity3 = class {
      constructor(id, props) {
        this._id = id;
        this._props = props;
      }
      equals(entity) {
        return entity == null ? false : this._id === entity._id;
      }
    };
    exports.Entity = Entity3;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/dayjs/locale/ja.js
var require_ja = __commonJS({
  "node_modules/dayjs/locale/ja.js"(exports, module2) {
    !function(e, _) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = _(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_locale_ja = _(e.dayjs);
    }(exports, function(e) {
      "use strict";
      function _(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      var t = _(e), d = { name: "ja", weekdays: "\u65E5\u66DC\u65E5_\u6708\u66DC\u65E5_\u706B\u66DC\u65E5_\u6C34\u66DC\u65E5_\u6728\u66DC\u65E5_\u91D1\u66DC\u65E5_\u571F\u66DC\u65E5".split("_"), weekdaysShort: "\u65E5_\u6708_\u706B_\u6C34_\u6728_\u91D1_\u571F".split("_"), weekdaysMin: "\u65E5_\u6708_\u706B_\u6C34_\u6728_\u91D1_\u571F".split("_"), months: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e2) {
        return e2 + "\u65E5";
      }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5 HH:mm", LLLL: "YYYY\u5E74M\u6708D\u65E5 dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5(ddd) HH:mm" }, meridiem: function(e2) {
        return e2 < 12 ? "\u5348\u524D" : "\u5348\u5F8C";
      }, relativeTime: { future: "%s\u5F8C", past: "%s\u524D", s: "\u6570\u79D2", m: "1\u5206", mm: "%d\u5206", h: "1\u6642\u9593", hh: "%d\u6642\u9593", d: "1\u65E5", dd: "%d\u65E5", M: "1\u30F6\u6708", MM: "%d\u30F6\u6708", y: "1\u5E74", yy: "%d\u5E74" } };
      return t.default.locale(d, null, true), d;
    });
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module2) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var a = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3) return 0;
          if ("Z" === e3) return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], h = function(e2) {
        var t2 = o[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, u = function(e2, t2) {
        var n2, r2 = o.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
        } else n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, d = { A: [i, function(e2) {
        this.afternoon = u(e2, false);
      }], a: [i, function(e2) {
        this.afternoon = u(e2, true);
      }], S: [/\d/, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [n, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
        var t2 = o.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
        var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1) throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [i, function(e2) {
        var t2 = h("months").indexOf(e2) + 1;
        if (t2 < 1) throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
        this.year = s(e2);
      }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
      function c(n2) {
        var r2, i2;
        r2 = n2, i2 = o && o.formats;
        for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o2 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
          s2[f2] = l ? { regex: c2, parser: l } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = s2[n3];
            if ("string" == typeof i3) r3 += i3.length;
            else {
              var o2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
          this.$u = r3;
          var a2 = s2[1];
          if ("string" == typeof a2) {
            var f2 = true === s2[2], h2 = true === s2[3], u2 = f2 || h2, d2 = s2[2];
            h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
              try {
                if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = /* @__PURE__ */ new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
                i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
          } else if (a2 instanceof Array) for (var l = a2.length, m = 1; m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e3);
        };
      };
    });
  }
});

// node_modules/owlelia/dist/bundle/datetime.js
var require_datetime = __commonJS({
  "node_modules/owlelia/dist/bundle/datetime.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = void 0;
    var vo_1 = require_vo();
    var dayjs_1 = __importDefault(require_dayjs_min());
    require_ja();
    var customParseFormat_1 = __importDefault(require_customParseFormat());
    dayjs_1.default.extend(customParseFormat_1.default);
    var pad002 = (v) => String(v).padStart(2, "0");
    function keyBy(xs, toKey) {
      const result = {};
      for (const x of xs) {
        result[toKey(x)] = x;
      }
      return result;
    }
    function toHHmmss2(seconds) {
      const hour = seconds / (60 * 60) | 0;
      const min = seconds % (60 * 60) / 60 | 0;
      const sec = seconds % 60;
      return `${pad002(hour)}:${pad002(min)}:${pad002(sec)}`;
    }
    var DateTime9 = class _DateTime extends vo_1.ValueObject {
      /**
       * Set specific holidays.
       * It is used by {@link DateTime.isHoliday}, {@link DateTime.isWeekday} and so on.
       * @param dates  String date formats which can supported by {@link DateTime.of}
       *
       * @example Set 2020-01-01, 2020-01-02 and 2020-01-03 as a holiday.
       * ```typescript
       * DateTime.setHolidays("2020-01-01", "2020-01-02", "2020-01-03")
       * ```
       */
      static setHolidays(...dates) {
        this.holidays = dates.map(_DateTime.of);
        this.holidayByDisplayDate = keyBy(this.holidays, (x) => x.displayDate);
      }
      /**
       * Create instance from any formats.
       * @param value
       *
       * @example
       * ```typescript
       * DateTime.of("2020-02-02")
       *   // -> 2020-02-02T00:00:00
       * DateTime.of("2020-02-02 10:10:10")
       *   // -> 2020-02-02T10:10:10
       * DateTime.of("2020/02/02")
       *   // -> 2020-02-02T00:00:00
       * DateTime.of("2020/02/02 20:20:20")
       *   // -> 2020-02-02T20:20:20
       * DateTime.of(new Date(2020, 0, 1, 0, 1, 30, 0))
       *   // -> 2020-01-01T00:01:30
       * DateTime.of(1633579856)
       *   // -> 2021-10-07T14:23:47
       * ```
       */
      static of(value) {
        return new _DateTime((0, dayjs_1.default)(typeof value === "number" ? value * 1e3 : value));
      }
      /**
       * Create instance from specific formats.
       * @param value
       * @param format [Available format](https://day.js.org/docs/en/parse/string-format#list-of-all-available-parsing-tokens)
       *
       * @example
       * ```typescript
       * DateTime.of("02-02-2020", "MM-DD-YYYY")
       *   // -> 2020-02-02T00:00:00
       * DateTime.of("2020-02-02")
       *   // -> 2020-02-02T00:00:00
       * ```
       */
      static from(value, format) {
        return new _DateTime((0, dayjs_1.default)(value, format));
      }
      /**
       * Create instance of now.
       */
      static now() {
        return new _DateTime((0, dayjs_1.default)());
      }
      /**
       * Create instance of today
       *
       * @example
       * ```typescript
       * // Now: 2020-01-01 23:03:00
       * DateTime.today()
       *   // -> 2020-01-01T00:00:00
       * ```
       */
      static today() {
        return new _DateTime((0, dayjs_1.default)().startOf("day"));
      }
      /**
       * Create instance of yesterday
       *
       * @example
       * ```typescript
       * // Now: 2020-01-01 23:03:00
       * DateTime.yesterday()
       *   // -> 2019-12-31T00:00:00
       * ```
       */
      static yesterday() {
        return _DateTime.today().minusDays(1);
      }
      /**
       * Create instance of today
       *
       * @example
       * ```typescript
       * // Now: 2020-01-01 23:03:00
       * DateTime.tomorrow()
       *   // -> 2020-01-02T00:00:00
       * ```
       */
      static tomorrow() {
        return _DateTime.today().plusDays(1);
      }
      /**
       * Check whether the format is valid or not.
       * @param value
       * @param format
       *
       * @example
       * ```typescript
       * DateTime.isValid("2020-01-01", "YYYY-MM-DD")
       *   // -> true
       * DateTime.isValid("2020-01-01", "YYYY/MM/DD")
       *   // -> false
       * DateTime.isValid("2020-01-31", "YYYY-MM-DD")
       *   // -> false
       * ```
       */
      static isValid(value, format) {
        return (0, dayjs_1.default)(value, format).format(format) === value;
      }
      /**
       * Clone a instance
       */
      clone() {
        return new _DateTime(this._value.clone());
      }
      /**
       * @param end
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").toDate(DateTime.of("2020-01-03 10:00:00"))
       *   // -> [2020-01-01T00:00:00, 2020-01-02T00:00:00, 2020-01-03T00:00:00]
       * DateTime.of("2020-01-03 10:00:00").toDate(DateTime.of("2020-01-01 10:00:00"))
       *   // -> [2020-01-03T00:00:00, 2020-01-02T00:00:00, 2020-01-01T00:00:00]
       * ```
       */
      toDate(end) {
        let bd = this.midnight();
        let ed = end.midnight();
        if (bd.equals(ed)) {
          return [bd, ed];
        }
        let dates = [bd];
        const reverse = ed.isBefore(bd);
        while (!bd.equals(ed)) {
          bd = reverse ? bd.minusDays(1) : bd.plusDays(1);
          dates.push(bd);
        }
        return dates;
      }
      /**
       * @param year
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceYear(2029)
       *   // -> 2029-01-01T10:00:00
       * ```
       */
      replaceYear(year) {
        return new _DateTime(this._value.year(year));
      }
      /**
       * @param month
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceMonth(10)
       *   // -> 2020-10-01T10:00:00
       * ```
       */
      replaceMonth(month) {
        return new _DateTime(this._value.month(month - 1));
      }
      /**
       * @param day
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceDay(3)
       *   // -> 2020-01-03T10:00:00
       * ```
       */
      replaceDay(day) {
        return new _DateTime(this._value.date(day));
      }
      /**
       * @param hour
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceHour(3)
       *   // -> 2020-01-01T03:00:00
       * ```
       */
      replaceHour(hour) {
        return new _DateTime(this._value.hour(hour));
      }
      /**
       * @param minute
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceMinute(3)
       *   // -> 2020-01-01T10:03:00
       * ```
       */
      replaceMinute(minute) {
        return new _DateTime(this._value.minute(minute));
      }
      /**
       * @param second
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").replaceSecond(3)
       *   // -> 2020-01-01T10:00:03
       * ```
       */
      replaceSecond(second) {
        return new _DateTime(this._value.second(second));
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:01:02").midnight()
       *   // -> 2020-01-01T00:00:00
       * ```
       */
      midnight() {
        return new _DateTime(this._value.hour(0).minute(0).second(0).millisecond(0));
      }
      /**
       * @param months
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").plusMonths(2)
       *   // -> 2020-03-01T10:00:00
       * ```
       */
      plusMonths(months) {
        return new _DateTime(this._value.add(months, "month"));
      }
      /**
       * @param days
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").plusDays(3)
       *   // -> 2020-01-04T10:00:00
       * ```
       */
      plusDays(days2) {
        return new _DateTime(this._value.add(days2, "day"));
      }
      /**
       * @param weekdays
       *
       * @example 2020-12-01(Tue) - 2020-12-07(Mon). 2020-12-02 is a holiday!
       * ```typescript
       * DateTime.setHolidays("2020-12-02");
       *
       * DateTime.of("2020-12-01 00:00:00").plusWeekdays(2)
       *   // -> 2020-12-04T00:00:00
       * DateTime.of("2020-12-03 00:00:00").plusWeekdays(3)
       *   // -> 2020-12-08T00:00:00
       * ```
       */
      plusWeekdays(weekdays) {
        let d = this.clone();
        while (weekdays > 0) {
          d = d.plusDays(1);
          if (d.isWeekday) {
            weekdays--;
          }
        }
        return d;
      }
      /**
       * @param hours
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").plusHours(3)
       *   // -> 2020-01-01T13:00:00
       * ```
       */
      plusHours(hours) {
        return new _DateTime(this._value.add(hours, "hour"));
      }
      /**
       * @param minutes
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").plusMinutes(3)
       *   // -> 2020-01-01T10:03:00
       * ```
       */
      plusMinutes(minutes) {
        return new _DateTime(this._value.add(minutes, "minute"));
      }
      /**
       * @param seconds
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").plusSeconds(3)
       *   // -> 2020-01-01T10:00:03
       * ```
       */
      plusSeconds(seconds) {
        return new _DateTime(this._value.add(seconds, "second"));
      }
      /**
       * @param months
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").minusMonths(2)
       *   // -> 2019-11-01T10:00:00
       * ```
       */
      minusMonth(months) {
        return new _DateTime(this._value.subtract(months, "month"));
      }
      /**
       * @param days
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").minusDays(3)
       *   // -> 2019-12-29T10:00:00
       * ```
       */
      minusDays(days2) {
        return new _DateTime(this._value.subtract(days2, "day"));
      }
      /**
       * @param hours
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").minusHours(3)
       *   // -> 2020-01-01T07:00:00
       * ```
       */
      minusHours(hours) {
        return new _DateTime(this._value.subtract(hours, "hour"));
      }
      /**
       * @param minutes
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").minusMinutes(3)
       *   // -> 2020-01-01T09:57:00
       * ```
       */
      minusMinutes(minutes) {
        return new _DateTime(this._value.subtract(minutes, "minute"));
      }
      /**
       * @param seconds
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").minusSeconds(3)
       *   // -> 2020-01-01T09:59:57
       * ```
       */
      minusSeconds(seconds) {
        return new _DateTime(this._value.subtract(seconds, "second"));
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").endOfMonth()
       *   // -> 2020-01-31T10:00:00
       * ```
       */
      endOfMonth() {
        return new _DateTime(this._value.endOf("month"));
      }
      /**
       * Only overwrite year, month, and date.
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00")
       *   .overwriteDate("2020-02-02 17:00:00")
       *     // -> 2020-02-02T10:00:00
       * ```
       */
      overwriteDate(date) {
        return new _DateTime(this._value.year(date._value.year()).month(date._value.month()).date(date._value.date()));
      }
      /**
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 10:00:00").diffMonths(DateTime.of("2019-11-01 10:00:00"))
       *   // -> 2
       * DateTime.of("2019-12-31 23:59:59").diffMonths(DateTime.of("2020-01-01 00:00:00"))
       *   // -> -1
       * ```
       */
      diffMonths(date) {
        return this._value.startOf("month").diff(date._value.startOf("month"), "month");
      }
      /**
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2021-01-01 10:00:00").diffDays(DateTime.of("2020-12-30 22:00:00"))
       *   // -> 2
       * DateTime.of("2019-12-31 23:59:59").diffDays(DateTime.of("2020-01-01 00:00:00"))
       *   // -> -1
       * ```
       */
      diffDays(date) {
        return this._value.startOf("day").diff(date._value.startOf("day"), "day");
      }
      /**
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2021-01-01 10:00:00").diffHours(DateTime.of("2020-12-30 22:00:00"))
       *   // -> 36
       * DateTime.of("2019-12-31 23:59:59").diffHours(DateTime.of("2020-01-01 00:00:00"))
       *   // -> -1
       * ```
       */
      diffHours(date) {
        return this._value.startOf("hour").diff(date._value.startOf("hour"), "hour");
      }
      /**
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2021-01-01 10:00:00").diffMinutes(DateTime.of("2020-12-30 22:00:00"))
       *   // -> 2160
       * DateTime.of("2019-12-31 23:59:59").diffMinutes(DateTime.of("2020-01-01 00:00:00"))
       *   // -> -1
       * ```
       */
      diffMinutes(date) {
        return this._value.startOf("minute").diff(date._value.startOf("minute"), "minute");
      }
      /**
       * @param date
       *
       * @example
       * ```typescript
       * DateTime.of("2021-01-01 10:00:00").diffSeconds(DateTime.of("2020-12-30 22:00:00"))
       *   // -> 129600
       * DateTime.of("2019-12-31 23:59:59").diffSeconds(DateTime.of("2020-01-01 00:00:00"))
       *   // -> -1
       * ```
       */
      diffSeconds(date) {
        return this._value.startOf("second").diff(date._value.startOf("second"), "second");
      }
      diffMinutesFromNow() {
        return _DateTime.now()._value.diff(this._value, "minute");
      }
      diffSecondsFromNow() {
        return _DateTime.now()._value.diff(this._value, "second");
      }
      /**
       * HH:mm:ss (ex: 10:50:01)
       */
      displayDiffFromNow() {
        return toHHmmss2(_DateTime.now()._value.diff(this._value, "second"));
      }
      /**
       * ex
       *   00:00:48 -> 48秒
       *   00:02:11 -> 2分 (Ignore seconds in the case seconds >= 60)
       */
      displayDiffFromNowJapanese() {
        const hours = this._value.hour();
        const minutes = this._value.minute();
        const seconds = this._value.second();
        return [
          hours && `${hours}\u6642\u9593`,
          minutes && `${minutes}\u5206`,
          hours === 0 && minutes === 0 && `${seconds}\u79D2`
        ].filter((x) => x).join("");
      }
      within(seconds) {
        return _DateTime.now()._value.diff(this._value, "second") <= seconds;
      }
      equals(date, ignoreTime = false) {
        return ignoreTime ? this._value.isSame(date._value, "date") : this._value.isSame(date._value);
      }
      isAfter(date, ignoreTime = false) {
        return ignoreTime ? this._value.isAfter(date._value, "date") : this._value.isAfter(date._value);
      }
      isBefore(date, ignoreTime = false) {
        return ignoreTime ? this._value.isBefore(date._value, "date") : this._value.isBefore(date._value);
      }
      isAfterOrEquals(date, ignoreTime = false) {
        return this.isAfter(date, ignoreTime) || this.equals(date, ignoreTime);
      }
      isBeforeOrEquals(date, ignoreTime = false) {
        return this.isBefore(date, ignoreTime) || this.equals(date, ignoreTime);
      }
      between(begin, end, option = { includeBegin: true, includeEnd: true, ignoreTime: false }) {
        return (option.includeBegin ? this.isAfterOrEquals(begin, option.ignoreTime) : this.isAfter(begin, option.ignoreTime)) && (option.includeEnd ? this.isBeforeOrEquals(end, option.ignoreTime) : this.isBefore(end, option.ignoreTime));
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 10:12:00").format("YYYY年M月D日")
       *   // -> 2020年2月1日
       * ```
       */
      format(template) {
        return this._value.format(template);
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 10:00:00").year
       *   // -> 2020
       * ```
       */
      get year() {
        return this._value.year();
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 10:00:00").month
       *   // -> 2
       * ```
       */
      get month() {
        return this._value.month() + 1;
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 10:00:00").day
       *   // -> 1
       * ```
       */
      get day() {
        return this._value.date();
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 10:00:00").yearMonth
       *   // -> 202002
       * ```
       */
      get yearMonth() {
        return this.year * 100 + this.month;
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 12:34:56").hour
       *   // -> 12
       * ```
       */
      get hour() {
        return this._value.hour();
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 12:34:56").minute
       *   // -> 34
       * ```
       */
      get minute() {
        return this._value.minute();
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-02-01 12:34:56").second
       *   // -> 56
       * ```
       */
      get second() {
        return this._value.second();
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-01-05 00:00:00").isStartOfDay
       *   // -> true
       * DateTime.of("2020-01-05 00:00:01").isStartOfDay
       *   // -> false
       * ```
       */
      get isStartOfDay() {
        return this._value.startOf("day").isSame(this._value);
      }
      /**
       * @example 2020-12-07(Mon)
       * ```typescript
       * DateTime.of("2020-12-07 00:00:00").isMonday
       *   // -> true
       * DateTime.of("2020-12-07 23:59:59").isMonday
       *   // -> true
       * ```
       */
      get isMonday() {
        return this._value.day() === 1;
      }
      /**
       * @example 2020-12-08(Tue)
       * ```typescript
       * DateTime.of("2020-12-08 00:00:00").isTuesday
       *   // -> true
       * DateTime.of("2020-12-08 23:59:59").isTuesday
       *   // -> true
       * ```
       */
      get isTuesday() {
        return this._value.day() === 2;
      }
      /**
       * @example 2020-12-09(Wed)
       * ```typescript
       * DateTime.of("2020-12-09 00:00:00").isWednesday
       *   // -> true
       * DateTime.of("2020-12-09 23:59:59").isWednesday
       *   // -> true
       * ```
       */
      get isWednesday() {
        return this._value.day() === 3;
      }
      /**
       * @example 2020-12-10(Thu)
       * ```typescript
       * DateTime.of("2020-12-10 00:00:00").isThursday
       *   // -> true
       * DateTime.of("2020-12-10 23:59:59").isThursday
       *   // -> true
       * ```
       */
      get isThursday() {
        return this._value.day() === 4;
      }
      /**
       * @example 2020-12-11(Fri)
       * ```typescript
       * DateTime.of("2020-12-11 00:00:00").isFriday
       *   // -> true
       * DateTime.of("2020-12-11 23:59:59").isFriday
       *   // -> true
       * ```
       */
      get isFriday() {
        return this._value.day() === 5;
      }
      /**
       * @example 2020-12-04(Fri), 2020-12-05(Sat), 2020-12-06(Sun)
       * ```typescript
       * DateTime.of("2020-12-04 00:00:00").isSunday
       *   // -> false
       * DateTime.of("2020-12-05 10:00:00").isSunday
       *   // -> true
       * DateTime.of("2020-12-06 23:59:59").isSunday
       *   // -> false
       * ```
       */
      get isSaturday() {
        return this._value.day() === 6;
      }
      /**
       * @example 2020-12-04(Fri), 2020-12-05(Sat), 2020-12-06(Sun)
       * ```typescript
       * DateTime.of("2020-12-04 00:00:00").isSunday
       *   // -> false
       * DateTime.of("2020-12-05 10:00:00").isSunday
       *   // -> false
       * DateTime.of("2020-12-06 23:59:59").isSunday
       *   // -> true
       * ```
       */
      get isSunday() {
        return this._value.day() === 0;
      }
      /**
       * @example
       * ```typescript
       * DateTime.setHolidays("2020-07-07", "2020-12-24")
       *
       * DateTime.of("2020-01-01 00:00:00").isHoliday
       *   // -> false
       * DateTime.of("2020-07-07 10:00:00").isHoliday
       *   // -> true
       * DateTime.of("2020-12-24 23:59:59").isHoliday
       *   // -> true
       * ```
       */
      get isHoliday() {
        return !!_DateTime.holidayByDisplayDate[this.displayDate];
      }
      /**
       * @example 2020-12-01(Tue) - 2020-12-07(Mon). 2020-12-02 is a holiday!
       * ```typescript
       * DateTime.setHolidays("2020-12-02");
       *
       * DateTime.of("2020-12-01 00:00:00").isWeekday
       *   // -> true
       * DateTime.of("2020-12-02 03:00:00").isWeekday
       *   // -> false
       * DateTime.of("2020-12-03 06:00:00").isWeekday
       *   // -> true
       * DateTime.of("2020-12-04 09:00:00").isWeekday
       *   // -> true
       * DateTime.of("2020-12-05 12:00:00").isWeekday
       *   // -> false
       * DateTime.of("2020-12-06 15:00:00").isWeekday
       *   // -> false
       * DateTime.of("2020-12-07 18:00:00").isWeekday
       *   // -> true
       * ```
       */
      get isWeekday() {
        return !(this.isSaturday || this.isSunday || this.isHoliday);
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2023-02-04 00:00:00").isNthDayOfWeek()
       *   // -> 1
       * DateTime.of("2023-02-05 00:00:00").isNthDayOfWeek()
       *   // -> 1
       * DateTime.of("2023-02-11 00:00:00").isNthDayOfWeek()
       *   // -> 2
       * DateTime.of("2023-02-12 00:00:00").isNthDayOfWeek()
       *   // -> 2
       * ```
       */
      get nthDayOfWeek() {
        return Math.ceil(this.day / 7);
      }
      /**
       * @example
       * ```typescript
       * DateTime.of("2020-01-01 00:01:30").date
       *   // -> equals to new Date(2020, 0, 1, 0, 1, 30, 0)
       * ```
       */
      get date() {
        return this._value.toDate();
      }
      /**
       * ex: 1970-01-01 00:01:30 -> 90
       */
      get unix() {
        return this._value.unix();
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02T08:23:01+00:00
       */
      get rfc3339() {
        return this._value.format("YYYY-MM-DDTHH:mm:ssZ");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02T08:23:01
       */
      get rfc3339WithoutTimezone() {
        return this._value.format("YYYY-MM-DDTHH:mm:ss");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 08:23:01
       */
      get displayTime() {
        return this._value.format("HH:mm:ss");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 08:23
       */
      get displayTimeWithoutSeconds() {
        return this._value.format("HH:mm");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02
       */
      get displayDate() {
        return this._value.format("YYYY-MM-DD");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02 (Fri)
       */
      get displayDateFull() {
        return this._value.format("YYYY-MM-DD (ddd)");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02 08:23:01
       */
      get displayDateTime() {
        return this._value.format("YYYY-MM-DD HH:mm:ss");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 2020-10-02 08:23
       */
      get displayDateTimeWithoutSeconds() {
        return this._value.format("YYYY-MM-DD HH:mm");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 20201002
       */
      get yyyyMMdd() {
        return this._value.format("YYYYMMDD");
      }
      /**
       * ex: 2020-10-02 08:23:01 -> 20201002082301
       */
      get yyyyMMddHHmmss() {
        return this._value.format("YYYYMMDDHHmmss");
      }
    };
    exports.DateTime = DateTime9;
  }
});

// node_modules/owlelia/dist/bundle/utils.js
var require_utils = __commonJS({
  "node_modules/owlelia/dist/bundle/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.round = void 0;
    function round(n, decimalPlace) {
      const x = Math.pow(10, decimalPlace);
      return Math.round(n * x) / x;
    }
    exports.round = round;
    function isEmpty(arg) {
      return [Object, Array].includes((arg || {}).constructor) && !Object.entries(arg || {}).length;
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/owlelia/dist/bundle/values.js
var require_values = __commonJS({
  "node_modules/owlelia/dist/bundle/values.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LiquidValue = void 0;
    var utils_1 = require_utils();
    var LiquidValue = class {
      constructor(value, loading = false, error = null) {
        this.value = value;
        this.loading = loading;
        this.error = error;
        this.initialValue = value;
      }
      isEmpty() {
        return (0, utils_1.isEmpty)(this.value);
      }
      load(asyncFunc, option) {
        return __awaiter(this, void 0, void 0, function* () {
          if (option === null || option === void 0 ? void 0 : option.clearValueBeforeLoading) {
            this.value = this.initialValue;
          }
          if (option === null || option === void 0 ? void 0 : option.clearErrorBeforeLoading) {
            this.error = null;
          }
          if (!(option === null || option === void 0 ? void 0 : option.silent)) {
            this.loading = true;
          }
          const ret = yield asyncFunc();
          if (ret.isErr()) {
            if (!(option === null || option === void 0 ? void 0 : option.keepValueIfError)) {
              this.value = this.initialValue;
            }
            this.error = ret.error;
          } else {
            this.error = null;
            this.value = ret.value;
          }
          if (!(option === null || option === void 0 ? void 0 : option.silent)) {
            this.loading = false;
          }
        });
      }
    };
    exports.LiquidValue = LiquidValue;
  }
});

// node_modules/owlelia/dist/result.js
var require_result = __commonJS({
  "node_modules/owlelia/dist/result.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromPromise = exports.aggregate = exports.ok = exports.err = void 0;
    var Ok = class _Ok {
      constructor(value) {
        this.value = value;
        this._type = "ok";
      }
      unwrap() {
        return [this.value, void 0];
      }
      isErr() {
        return false;
      }
      isOk() {
        return true;
      }
      get _err() {
        return void 0;
      }
      get _ok() {
        return this.value;
      }
      mapErr(_functor) {
        return new _Ok(this.value);
      }
      map(functor) {
        return new _Ok(functor(this.value));
      }
      biMap(functor, errFunctor) {
        return this.mapErr(errFunctor).map(functor);
      }
      fold(functor, _errFunctor) {
        return functor(this.value);
      }
      // noinspection JSUnusedLocalSymbols
      or(value) {
        return this.value;
      }
      orUndefined() {
        return this.value;
      }
      orNull() {
        return this.value;
      }
      orThrow() {
        return this.value;
      }
    };
    var Err = class _Err {
      constructor(error) {
        this.error = error;
        this._type = "err";
      }
      unwrap() {
        return [void 0, this.error];
      }
      isErr() {
        return true;
      }
      isOk() {
        return false;
      }
      get _err() {
        return this.error;
      }
      get _ok() {
        return void 0;
      }
      mapErr(functor) {
        return new _Err(functor(this.error));
      }
      // noinspection JSUnusedLocalSymbols
      map(functor) {
        return new _Err(this.error);
      }
      biMap(functor, errFunctor) {
        return this.mapErr(errFunctor).map(functor);
      }
      fold(functor, errFunctor) {
        return errFunctor(this.error);
      }
      or(value) {
        return value;
      }
      orUndefined() {
        return void 0;
      }
      orNull() {
        return null;
      }
      orThrow() {
        throw this.error;
      }
    };
    var err2 = (error) => new Err(error);
    exports.err = err2;
    var ok2 = (value) => new Ok(value);
    exports.ok = ok2;
    function aggregate2(results) {
      const errors = results.filter((x) => x.isErr()).flatMap((x) => x._err);
      const values = results.filter((x) => x.isOk()).map((x) => x._ok);
      return errors.length > 0 ? (0, exports.err)(errors) : (0, exports.ok)(values);
    }
    exports.aggregate = aggregate2;
    function fromPromise3(promise) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          return (0, exports.ok)(yield promise);
        } catch (e) {
          return (0, exports.err)(e);
        }
      });
    }
    exports.fromPromise = fromPromise3;
  }
});

// node_modules/owlelia/dist/index.js
var require_dist = __commonJS({
  "node_modules/owlelia/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LiquidValue = exports.DateTime = exports.BaseError = exports.Entity = exports.PrimitiveValueObject = exports.ValueObject = void 0;
    var vo_1 = require_vo();
    Object.defineProperty(exports, "ValueObject", { enumerable: true, get: function() {
      return vo_1.ValueObject;
    } });
    Object.defineProperty(exports, "PrimitiveValueObject", { enumerable: true, get: function() {
      return vo_1.PrimitiveValueObject;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return error_1.BaseError;
    } });
    var entity_1 = require_entity();
    Object.defineProperty(exports, "Entity", { enumerable: true, get: function() {
      return entity_1.Entity;
    } });
    var datetime_1 = require_datetime();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return datetime_1.DateTime;
    } });
    var values_1 = require_values();
    Object.defineProperty(exports, "LiquidValue", { enumerable: true, get: function() {
      return values_1.LiquidValue;
    } });
    __exportStar(require_result(), exports);
    __exportStar(require_utils(), exports);
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SilhouettePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/settings-helper.ts
var TextComponentEvent;
((TextComponentEvent2) => {
  function onChange(component, handler) {
    component.inputEl.addEventListener("change", async (ev) => {
      if (!(ev.target instanceof HTMLInputElement)) {
        return;
      }
      handler(ev.target.value);
    });
    return component;
  }
  TextComponentEvent2.onChange = onChange;
})(TextComponentEvent || (TextComponentEvent = {}));

// src/settings.ts
var DEFAULT_SETTINGS = {
  taskFilePath: "",
  holidayFilePath: "",
  fileDateFormat: "",
  timerStorageFilePath: "",
  showTimeOnStatusBar: false,
  startNextTaskAutomaticallyAfterDone: false
};
var SilhouetteSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("\u7E70\u308A\u8FD4\u3057\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u306E\u30D1\u30B9").setDesc(
      "\u7E70\u308A\u8FD4\u3057\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u306E\u30D1\u30B9\u3092Vault root\u304B\u3089\u306E\u76F8\u5BFE\u30D1\u30B9\u3068\u3057\u3066\u6307\u5B9A\u3057\u307E\u3059\u3002"
    ).addText(
      (text2) => TextComponentEvent.onChange(text2, async (value) => {
        this.plugin.settings.taskFilePath = value;
        await this.plugin.saveSettings();
      }).setPlaceholder("ex: taskfile.md").setValue(this.plugin.settings.taskFilePath)
    );
    new import_obsidian.Setting(containerEl).setName("\u4F11\u65E5\u8A2D\u5B9A\u30D5\u30A1\u30A4\u30EB\u306E\u30D1\u30B9").setDesc(
      "\u4F11\u65E5\u8A2D\u5B9A\u30D5\u30A1\u30A4\u30EB\u306E\u30D1\u30B9\u3092Vault root\u304B\u3089\u306E\u76F8\u5BFE\u30D1\u30B9\u3068\u3057\u3066\u6307\u5B9A\u3057\u307E\u3059\u3002"
    ).addText(
      (text2) => TextComponentEvent.onChange(text2, async (value) => {
        this.plugin.settings.holidayFilePath = value;
        await this.plugin.saveSettings();
      }).setPlaceholder("ex: holiday.md").setValue(this.plugin.settings.holidayFilePath)
    );
    new import_obsidian.Setting(containerEl).setName("\u30D5\u30A1\u30A4\u30EB\u306E\u65E5\u4ED8\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8").setDesc(
      "\u30BF\u30B9\u30AF\u3092\u633F\u5165\u3059\u308B\u65E5\u4ED8\u3092\u5224\u65AD\u3059\u308B\u305F\u3081\u306B\u5FC5\u8981\u306A\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u3092\u6307\u5B9A\u3057\u307E\u3059\u3002"
    ).addText(
      (text2) => TextComponentEvent.onChange(text2, async (value) => {
        this.plugin.settings.fileDateFormat = value;
        await this.plugin.saveSettings();
      }).setPlaceholder("ex: MM-DD-YYYY").setValue(this.plugin.settings.fileDateFormat)
    );
    new import_obsidian.Setting(containerEl).setName("\u8A08\u6E2C\u72B6\u614B\u3092\u8A18\u9332\u3057\u305FJSON\u30D5\u30A1\u30A4\u30EB\u306E\u30D1\u30B9").setDesc(
      "\u8A08\u6E2C\u4E2D\u306E\u72B6\u614B\u3092\u8A18\u9332\u3057\u305FJSON\u30D5\u30A1\u30A4\u30EB\u3092\u4FDD\u5B58\u3059\u308B\u30D1\u30B9\u3092\u3001Vault root\u304B\u3089\u306E\u76F8\u5BFE\u30D1\u30B9\u3068\u3057\u3066\u6307\u5B9A\u3057\u307E\u3059\u3002\u6307\u5B9A\u3057\u306A\u304B\u3063\u305F\u5834\u5408\u306F`.obsidian/plugins/silhouette/timer.json`\u306B\u4FDD\u5B58\u3055\u308C\u307E\u3059\u3002"
    ).addText(
      (text2) => TextComponentEvent.onChange(text2, async (value) => {
        this.plugin.settings.timerStorageFilePath = value;
        await this.plugin.saveSettings();
      }).setPlaceholder("ex: timer.json").setValue(this.plugin.settings.timerStorageFilePath)
    );
    new import_obsidian.Setting(containerEl).setName("\u30B9\u30C6\u30FC\u30BF\u30B9\u30D0\u30FC\u306B\u8A08\u6E2C\u6642\u9593\u3092\u8868\u793A\u3059\u308B").setDesc(
      "\u6709\u52B9\u306B\u3059\u308B\u3068\u8A08\u6E2C\u4E2D\u30BF\u30B9\u30AF\u306E\u8A08\u6E2C\u6642\u9593\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002\u66F4\u65B0\u983B\u5EA6\u306F30\u79D2\u306B1\u56DE\u3067\u3059\u3002"
    ).addToggle((tc) => {
      tc.setValue(this.plugin.settings.showTimeOnStatusBar).onChange(
        async (value) => {
          this.plugin.settings.showTimeOnStatusBar = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("\u5B8C\u4E86\u3057\u305F\u3089\u6B21\u306E\u30BF\u30B9\u30AF\u3092\u81EA\u52D5\u3067\u8A08\u6E2C\u958B\u59CB\u3059\u308B").setDesc(
      "\u6709\u52B9\u306B\u3059\u308B\u3068\u300Ecycle bullet/checkbox\u300F\u30B3\u30DE\u30F3\u30C9\u3067\u30BF\u30B9\u30AF\u3092\u5B8C\u4E86\u3057\u305F\u3042\u3068\u3001\u6B21\u306E\u884C\u306B\u672A\u5B8C\u4E86\u306E\u30BF\u30B9\u30AF\u304C\u5B58\u5728\u3059\u308B\u306A\u3089\u3001\u6B21\u306E\u884C\u306E\u30BF\u30B9\u30AF\u3092\u81EA\u52D5\u3067\u8A08\u6E2C\u958B\u59CB\u3057\u307E\u3059\u3002"
    ).addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.startNextTaskAutomaticallyAfterDone
      ).onChange(async (value) => {
        this.plugin.settings.startNextTaskAutomaticallyAfterDone = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/app-helper.ts
var import_obsidian2 = require("obsidian");

// src/errors.ts
var ExhaustiveError = class extends Error {
  constructor(value, message = `Unsupported type: ${value}`) {
    super(message);
  }
};

// src/app-helper.ts
function createCommand(leaf) {
  switch (leaf) {
    case "same-tab":
      return "editor:follow-link";
    case "new-tab":
      return "editor:open-link-in-new-leaf";
    default:
      throw new ExhaustiveError(leaf);
  }
}
var AppHelper = class {
  constructor(app) {
    this.unsafeApp = app;
  }
  async exists(path) {
    return await this.unsafeApp.vault.adapter.exists(path);
  }
  async deleteFile(path) {
    await this.unsafeApp.vault.adapter.remove(path);
  }
  async deleteFileIfExists(path) {
    if (await this.exists(path)) {
      await this.deleteFile(path);
    }
  }
  async loadFile(path) {
    if (!await this.exists(path)) {
      throw Error(`The file is not found: ${path}`);
    }
    return this.unsafeApp.vault.adapter.read(path);
  }
  async loadJson(path) {
    return JSON.parse(await this.loadFile(path));
  }
  async saveJson(path, data) {
    await this.unsafeApp.vault.adapter.write(
      path,
      JSON.stringify(data, null, 2)
    );
  }
  getActiveFile() {
    return this.unsafeApp.workspace.getActiveFile();
  }
  getActiveMarkdownView() {
    return this.unsafeApp.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
  }
  getActiveMarkdownEditor() {
    var _a2, _b;
    return (_b = (_a2 = this.getActiveMarkdownView()) == null ? void 0 : _a2.editor) != null ? _b : null;
  }
  getActiveFileContent() {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return null;
    }
    return editor.getValue();
  }
  getActiveLine() {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return null;
    }
    return editor.getLine(editor.getCursor().line);
  }
  getActiveNextLine() {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return null;
    }
    return editor.getLine(editor.getCursor().line + 1);
  }
  moveNextLine() {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return;
    }
    const { line } = editor.getCursor();
    return editor.setCursor({ line: line + 1, ch: 0 });
  }
  openLinkInActiveLine(option) {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return;
    }
    const line = this.getActiveLine();
    if (!line) {
      return;
    }
    const linksMatches = Array.from(
      line.matchAll(
        /(?<link>\[\[[^\]]+]])|[ |\n|^|\(](?<url>https?:\/\/[^ )\n]+)/g
      )
    );
    const firstIndex = linksMatches.map((x) => x.index).at(0);
    if (firstIndex === void 0) {
      return;
    }
    editor.setCursor({ line: editor.getCursor().line, ch: firstIndex + 3 });
    this.executeCoreCommand(createCommand(option.leaf));
  }
  insertStringToActiveFile(str) {
    var _a2;
    (_a2 = this.getActiveMarkdownEditor()) == null ? void 0 : _a2.replaceSelection(str);
  }
  replaceStringInActiveLine(str, option) {
    const editor = this.getActiveMarkdownEditor();
    if (!editor) {
      return;
    }
    const { line, ch } = editor.getCursor();
    editor.setLine(line, str);
    const afterCh = (option == null ? void 0 : option.cursor) === "last" ? str.length : Math.min(ch, str.length - 1);
    editor.setCursor({ line, ch: afterCh });
  }
  cycleListCheckList() {
    return this.unsafeApp.commands.executeCommandById(
      "editor:cycle-list-checklist"
    );
  }
  isCheckedCurrentLineTask() {
    const line = this.getActiveLine();
    return line ? /[-*] \[x] .+/.test(line) : false;
  }
  executeCoreCommand(command) {
    return this.unsafeApp.commands.executeCommandById(command);
  }
  removeCommand(commandId) {
    this.unsafeApp.commands.removeCommand(commandId);
  }
};

// node_modules/@tadashi-aikawa/silhouette-core/domain/vo/Repetition.js
var import_owlelia = __toESM(require_dist(), 1);

// node_modules/@tadashi-aikawa/silhouette-core/util/errors.js
var ExhaustiveError2 = class extends Error {
  constructor(value, message = `Unsupported type: ${value}`) {
    super(message);
  }
};
var ParseError = class extends Error {
};

// node_modules/@tadashi-aikawa/silhouette-core/util/strings.js
function match(text2, pattern2) {
  var _a2;
  return ((_a2 = pattern2.exec(text2)) == null ? void 0 : _a2[0]) === text2;
}

// node_modules/@tadashi-aikawa/silhouette-core/util/collections.js
function uniq(values) {
  return [
    ...new Set(values)
  ];
}

// node_modules/@tadashi-aikawa/silhouette-core/domain/vo/Repetition.js
var DAY_OF_WEEK_MAPPINGS = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6,
  "1sun": 10,
  "1mon": 11,
  "1tue": 12,
  "1wed": 13,
  "1thu": 14,
  "1fri": 15,
  "1sat": 16,
  "2sun": 20,
  "2mon": 21,
  "2tue": 22,
  "2wed": 23,
  "2thu": 24,
  "2fri": 25,
  "2sat": 26,
  "3sun": 30,
  "3mon": 31,
  "3tue": 32,
  "3wed": 33,
  "3thu": 34,
  "3fri": 35,
  "3sat": 36,
  "4sun": 40,
  "4mon": 41,
  "4tue": 42,
  "4wed": 43,
  "4thu": 44,
  "4fri": 45,
  "4sat": 46,
  "5sun": 50,
  "5mon": 51,
  "5tue": 52,
  "5wed": 53,
  "5thu": 54,
  "5fri": 55,
  "5sat": 56
};
var DAY_OF_WEEK_WORKDAY_MAPPINGS = {
  "sun!": 0,
  "mon!": 1,
  "tue!": 2,
  "wed!": 3,
  "thu!": 4,
  "fri!": 5,
  "sat!": 6,
  "1sun!": 10,
  "1mon!": 11,
  "1tue!": 12,
  "1wed!": 13,
  "1thu!": 14,
  "1fri!": 15,
  "1sat!": 16,
  "2sun!": 20,
  "2mon!": 21,
  "2tue!": 22,
  "2wed!": 23,
  "2thu!": 24,
  "2fri!": 25,
  "2sat!": 26,
  "3sun!": 30,
  "3mon!": 31,
  "3tue!": 32,
  "3wed!": 33,
  "3thu!": 34,
  "3fri!": 35,
  "3sat!": 36,
  "4sun!": 40,
  "4mon!": 41,
  "4tue!": 42,
  "4wed!": 43,
  "4thu!": 44,
  "4fri!": 45,
  "4sat!": 46,
  "5sun!": 50,
  "5mon!": 51,
  "5tue!": 52,
  "5wed!": 53,
  "5thu!": 54,
  "5fri!": 55,
  "5sat!": 56
};
var DAY_OF_WEEK_HOLIDAY_MAPPINGS = {
  "sun*": 0,
  "mon*": 1,
  "tue*": 2,
  "wed*": 3,
  "thu*": 4,
  "fri*": 5,
  "sat*": 6,
  "1sun*": 10,
  "1mon*": 11,
  "1tue*": 12,
  "1wed*": 13,
  "1thu*": 14,
  "1fri*": 15,
  "1sat*": 16,
  "2sun*": 20,
  "2mon*": 21,
  "2tue*": 22,
  "2wed*": 23,
  "2thu*": 24,
  "2fri*": 25,
  "2sat*": 26,
  "3sun*": 30,
  "3mon*": 31,
  "3tue*": 32,
  "3wed*": 33,
  "3thu*": 34,
  "3fri*": 35,
  "3sat*": 36,
  "4sun*": 40,
  "4mon*": 41,
  "4tue*": 42,
  "4wed*": 43,
  "4thu*": 44,
  "4fri*": 45,
  "4sat*": 46,
  "5sun*": 50,
  "5mon*": 51,
  "5tue*": 52,
  "5wed*": 53,
  "5thu*": 54,
  "5fri*": 55,
  "5sat*": 56
};
var repetitionBase = {
  day: {
    type: "period",
    period: 1
  },
  dayOfWeek: [
    0,
    1,
    2,
    3,
    4,
    5,
    6
  ],
  dayOfWeekHoliday: [
    0,
    1,
    2,
    3,
    4,
    5,
    6
  ],
  week: {
    type: "period",
    period: 1
  },
  month: {
    type: "period",
    period: 1
  },
  dayOffset: 0,
  workdayOffset: 0
};
function divideTokenWithOffset(token) {
  const [tp, pastOffset] = token.split("<");
  if (pastOffset === "!") {
    return [
      tp,
      0,
      0,
      "prev"
    ];
  }
  if (pastOffset) {
    return pastOffset.endsWith("!") ? [
      tp,
      0,
      -1 * Number(pastOffset.slice(0, -1)),
      void 0
    ] : [
      tp,
      -1 * Number(pastOffset),
      0,
      void 0
    ];
  }
  const [tf, futureOffset] = token.split(">");
  if (futureOffset === "!") {
    return [
      tf,
      0,
      0,
      "next"
    ];
  }
  if (futureOffset) {
    return futureOffset.endsWith("!") ? [
      tf,
      0,
      Number(futureOffset.slice(0, -1)),
      void 0
    ] : [
      tf,
      Number(futureOffset),
      0,
      void 0
    ];
  }
  return [
    token,
    0,
    0,
    void 0
  ];
}
var Repetition = class _Repetition extends import_owlelia.ValueObject {
  static get everyDay() {
    return new _Repetition(repetitionBase);
  }
  static get weekday() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        1,
        2,
        3,
        4,
        5
      ],
      dayOfWeekHoliday: [
        1,
        2,
        3,
        4,
        5
      ]
    });
  }
  static get weekend() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        0,
        6
      ],
      dayOfWeekHoliday: [
        0,
        6
      ]
    });
  }
  static get workday() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        1,
        2,
        3,
        4,
        5
      ],
      dayOfWeekHoliday: []
    });
  }
  static get nonWorkday() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        0,
        6
      ],
      dayOfWeekHoliday: [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ]
    });
  }
  static everyNDay(nDay) {
    return new _Repetition({
      ...repetitionBase,
      day: {
        type: "period",
        period: nDay
      }
    });
  }
  static get endOfMonth() {
    return new _Repetition({
      ...repetitionBase,
      special: "end of month"
    });
  }
  static get workdayEndOfMonth() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        1,
        2,
        3,
        4,
        5
      ],
      dayOfWeekHoliday: [],
      special: "end of month"
    });
  }
  static get beginningOfMonth() {
    return new _Repetition({
      ...repetitionBase,
      special: "beginning of month"
    });
  }
  static get workdayBeginningOfMonth() {
    return new _Repetition({
      ...repetitionBase,
      dayOfWeek: [
        1,
        2,
        3,
        4,
        5
      ],
      dayOfWeekHoliday: [],
      special: "beginning of month"
    });
  }
  get day() {
    return this._value.day;
  }
  get dayOfWeek() {
    return this._value.dayOfWeek;
  }
  get dayOfWeekHoliday() {
    return this._value.dayOfWeekHoliday;
  }
  get week() {
    return this._value.week;
  }
  get month() {
    return this._value.month;
  }
  get dayOffset() {
    return this._value.dayOffset;
  }
  get workdayOffset() {
    return this._value.workdayOffset;
  }
  get workdayShift() {
    return this._value.workdayShift;
  }
  get special() {
    return this._value.special;
  }
  withOffset(args) {
    const { dayOffset, workdayOffset } = args;
    return new _Repetition({
      ...this._value,
      dayOffset,
      workdayOffset
    });
  }
  withWorkdayShift(workdayShift) {
    return new _Repetition({
      ...this._value,
      workdayShift
    });
  }
  /**
   * 文字列パターンから複数の繰り返し情報を生成します
   *
   * ```ts
   * Repetition.fromRepetitionsStr("non workday|tue/wed");
   * Repetition.fromRepetitionsStr("non workday|tue/wed|15d");
   * ```
   */
  static fromRepetitionsStr(repetitionsStr) {
    return (0, import_owlelia.aggregate)(repetitionsStr.split("|").map((x) => _Repetition.from(x)));
  }
  /**
   * 文字列パターンから1つの繰り返し情報を生成します
   *
   * ```ts
   * Repetition.from("weekday");
   * Repetition.from("sun!/mon!");
   * Repetition.from("workday end of month");
   * ```
   */
  static from(str) {
    var _a2, _b;
    const [token, dayOffset, workdayOffset, workdayShift] = divideTokenWithOffset(str);
    switch (token) {
      case "every day":
      case "everyday":
        return (0, import_owlelia.ok)(_Repetition.everyDay.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "weekday":
      case "week day":
        return (0, import_owlelia.ok)(_Repetition.weekday.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "weekend":
      case "week end":
        return (0, import_owlelia.ok)(_Repetition.weekend.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "workday":
      case "work day":
        return (0, import_owlelia.ok)(_Repetition.workday.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "non workday":
      case "non work day":
        return (0, import_owlelia.ok)(_Repetition.nonWorkday.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "end of month":
        return (0, import_owlelia.ok)(_Repetition.endOfMonth.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "workday end of month":
        return (0, import_owlelia.ok)(_Repetition.workdayEndOfMonth.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "beginning of month":
        return (0, import_owlelia.ok)(_Repetition.beginningOfMonth.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      case "workday beginning of month":
        return (0, import_owlelia.ok)(_Repetition.workdayBeginningOfMonth.withOffset({
          dayOffset,
          workdayOffset
        }).withWorkdayShift(workdayShift));
      default: {
        const dayPeriod = (_b = (_a2 = token.match(/every (?<period>\d+) day/)) == null ? void 0 : _a2.groups) == null ? void 0 : _b.period;
        if (dayPeriod) {
          return (0, import_owlelia.ok)(_Repetition.everyNDay(Number(dayPeriod)).withOffset({
            dayOffset,
            workdayOffset
          }).withWorkdayShift(workdayShift));
        }
      }
    }
    const mm = token.slice(0, 2);
    const dd = token.slice(2);
    if (match(mm, /(0[1-9]|1[0-2])/) && match(dd, /(0[1-9]|[12][0-9]|3[01])/)) {
      return (0, import_owlelia.ok)(new _Repetition({
        day: {
          type: "specific",
          values: [
            Number(dd)
          ]
        },
        dayOfWeek: [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        dayOfWeekHoliday: [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        week: {
          type: "period",
          period: 1
        },
        month: {
          type: "specific",
          values: [
            Number(mm)
          ]
        },
        dayOffset,
        workdayOffset,
        workdayShift
      }));
    }
    const tokens = token.split("/");
    const dayOfWeek = tokens.map((x) => {
      var _a3;
      return (_a3 = DAY_OF_WEEK_MAPPINGS[x]) != null ? _a3 : DAY_OF_WEEK_WORKDAY_MAPPINGS[x];
    }).filter((x) => x !== void 0);
    const dayOfWeekHoliday = tokens.map((x) => {
      var _a3;
      return (_a3 = DAY_OF_WEEK_MAPPINGS[x]) != null ? _a3 : DAY_OF_WEEK_HOLIDAY_MAPPINGS[x];
    }).filter((x) => x !== void 0);
    if (dayOfWeek.length > 0 || dayOfWeekHoliday.length > 0) {
      if (tokens.length !== uniq([
        ...dayOfWeek,
        ...dayOfWeekHoliday
      ]).length) {
        return (0, import_owlelia.err)(new ParseError(`\u66DC\u65E5\u3068\u305D\u308C\u4EE5\u5916\u306E\u30D1\u30BF\u30FC\u30F3\u3092/\u3067\u8907\u6570\u6307\u5B9A\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093 (\u5024: ${token})`));
      }
      return (0, import_owlelia.ok)(new _Repetition({
        day: {
          type: "period",
          period: 1
        },
        dayOfWeek,
        dayOfWeekHoliday,
        week: {
          type: "period",
          period: 1
        },
        month: {
          type: "period",
          period: 1
        },
        dayOffset,
        workdayOffset,
        workdayShift
      }));
    }
    const days2 = tokens.filter((x) => match(x, /(0?[1-9]|[12][0-9]|3[01])d/)).map((x) => Number(x.slice(0, -1)));
    const to = (x) => x.length > 0 ? {
      type: "specific",
      values: x
    } : {
      type: "period",
      period: 1
    };
    if (days2.length > 0) {
      if (days2.length !== tokens.length) {
        return (0, import_owlelia.err)(new ParseError(`\u6BCE\u6708\u7279\u5B9A\u65E5\u3068\u305D\u308C\u4EE5\u5916\u306E\u30D1\u30BF\u30FC\u30F3\u3092/\u3067\u8907\u6570\u6307\u5B9A\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093 (\u5024: ${token})`));
      }
      return (0, import_owlelia.ok)(new _Repetition({
        day: to(days2),
        dayOfWeek: [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        dayOfWeekHoliday: [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        week: {
          type: "period",
          period: 1
        },
        month: {
          type: "period",
          period: 1
        },
        dayOffset,
        workdayOffset,
        workdayShift
      }));
    }
    return (0, import_owlelia.err)(new ParseError(`"${token}" \u306F\u89E3\u6790\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u308B\u7E70\u308A\u8FD4\u3057\u30D1\u30BF\u30FC\u30F3\u3067\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002`));
  }
};

// node_modules/@tadashi-aikawa/silhouette-core/domain/entity/OnetimeTask.js
var import_owlelia2 = __toESM(require_dist(), 1);

// node_modules/@tadashi-aikawa/silhouette-core/domain/entity/RepetitionTask.js
var import_owlelia3 = __toESM(require_dist(), 1);
var RepetitionTask = class _RepetitionTask extends import_owlelia3.Entity {
  static of(props) {
    return new _RepetitionTask(props.name, props);
  }
  cloneWith(partial) {
    return _RepetitionTask.of({
      ...this._props,
      ...partial
    });
  }
  get name() {
    return this._props.name;
  }
  get indent() {
    var _a2;
    return (_a2 = this._props.indent) != null ? _a2 : "";
  }
  /**
   * エディタに挿入する形式に変換する
   * WARN: これは必ずしもワンタイムタスクに変換されるわけではない
   */
  toString() {
    if (this.name.startsWith("- ") || this.name.startsWith("* ")) {
      return `${this.indent}${this.name}`;
    }
    return `${this.indent}- [ ] ${this.name}`;
  }
  shouldTry(date, holidays) {
    return this._props.repetitions.some((r) => needTaskBy(date, holidays, r, this._props.baseDate));
  }
};
function needTaskBy(date, holidays, repetition, baseDate) {
  let targetDate = date.clone();
  if (repetition.workdayShift) {
    if (!isWorkday(date, holidays)) {
      return false;
    }
    let shiftedTargetDate = date.clone();
    const iterate = defineReverseDateIterateMethod(repetition.workdayShift);
    while (true) {
      shiftedTargetDate = iterate(shiftedTargetDate);
      if (isWorkday(shiftedTargetDate, holidays)) {
        break;
      }
      if (needTaskBy(shiftedTargetDate, holidays, repetition.withWorkdayShift(void 0), baseDate)) {
        return true;
      }
    }
  }
  if (repetition.dayOffset !== 0) {
    targetDate = date.minusDays(repetition.dayOffset);
  }
  if (repetition.workdayOffset !== 0) {
    const targetDates = reverseOffsetWorkdays(date, repetition.workdayOffset, holidays);
    if (targetDates.length === 0) {
      return false;
    }
    return targetDates.some((d) => needTaskBy(d, holidays, repetition.withOffset({
      dayOffset: 0,
      workdayOffset: 0
    }), baseDate));
  }
  if (baseDate == null ? void 0 : baseDate.isAfter(targetDate)) {
    return false;
  }
  if (!includesDay(targetDate, holidays, repetition)) {
    return false;
  }
  switch (repetition.special) {
    case void 0:
      break;
    case "beginning of month": {
      let beginD = targetDate.minusDays(1);
      while (beginD.isAfterOrEquals(targetDate.replaceDay(1), true)) {
        if (includesDay(beginD, holidays, repetition)) {
          return false;
        }
        beginD = beginD.minusDays(1);
      }
      break;
    }
    case "end of month": {
      let endD = targetDate.plusDays(1);
      while (endD.isBeforeOrEquals(targetDate.endOfMonth(), true)) {
        if (includesDay(endD, holidays, repetition)) {
          return false;
        }
        endD = endD.plusDays(1);
      }
      break;
    }
    default:
      throw new ExhaustiveError2(repetition.special);
  }
  if (repetition.day.type === "period") {
    if (repetition.day.period === 1) {
      return true;
    }
    if (!baseDate) {
      return false;
    }
    return targetDate.diffDays(baseDate) % repetition.day.period === 0;
  }
  return repetition.month.type === "specific" ? repetition.day.values.includes(targetDate.day) && repetition.month.values.includes(targetDate.month) : repetition.day.values.includes(targetDate.day);
}
function includesDay(date, holidays, repetition) {
  if (isHoliday(date, holidays)) {
    if (!repetition.dayOfWeekHoliday.includes(date.date.getDay()) && !repetition.dayOfWeekHoliday.includes(date.date.getDay() + 10 * date.nthDayOfWeek)) {
      return false;
    }
  } else {
    if (!repetition.dayOfWeek.includes(date.date.getDay()) && !repetition.dayOfWeek.includes(date.date.getDay() + 10 * date.nthDayOfWeek)) {
      return false;
    }
  }
  return true;
}
function isHoliday(date, holidays) {
  return holidays.some((x) => x.equals(date));
}
function isWeekday(date) {
  return date.isMonday || date.isTuesday || date.isWednesday || date.isThursday || date.isFriday;
}
function isWorkday(date, holidays) {
  return isWeekday(date) && !isHoliday(date, holidays);
}
function defineReverseDateIterateMethod(shiftDirection) {
  switch (shiftDirection) {
    case "prev":
      return (dt) => dt.plusDays(1);
    case "next":
      return (dt) => dt.minusDays(1);
    default:
      throw new ExhaustiveError2(shiftDirection);
  }
}
function reverseOffsetWorkdays(dst, days2, holidays) {
  if (!isWorkday(dst, holidays)) {
    return [];
  }
  const dates = [];
  let d = dst.clone();
  if (days2 > 0) {
    while (days2 > 0 || !isWorkday(d, holidays)) {
      if (isWorkday(d, holidays)) {
        days2 -= 1;
      }
      d = d.minusDays(1);
      if (days2 === 0) {
        dates.push(d);
      }
    }
  } else {
    while (days2 < 0 || !isWorkday(d, holidays)) {
      if (isWorkday(d, holidays)) {
        days2 += 1;
      }
      d = d.plusDays(1);
      if (days2 === 0) {
        dates.push(d);
      }
    }
  }
  return dates;
}

// src/repository/TaskRepositoryImpl.ts
var import_owlelia4 = __toESM(require_dist());
var TaskRepositoryImpl = class {
  constructor(appHelper, repetitionTasksFilePath, holidaysFilePath) {
    this.appHelper = appHelper;
    this.repetitionTasksFilePath = repetitionTasksFilePath;
    this.holidaysFilePath = holidaysFilePath;
  }
  loadRepetitionTasks() {
    return (0, import_owlelia4.fromPromise)(
      this.appHelper.loadFile(this.repetitionTasksFilePath).then((tasksStr) => {
        const recordOrErrors = tasksStr.split("\n").filter((line) => !line.startsWith("//") && line.trim() !== "").map((line) => line.split(",")).map(([name, repetitions, baseDate]) => {
          var _a2, _b;
          const _repetitions = repetitions == null ? void 0 : repetitions.trim();
          if (!_repetitions) {
            return {
              errors: [
                {
                  message: `${name}:
  \u7E70\u308A\u8FD4\u3057\u30D1\u30BF\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093`
                }
              ]
            };
          }
          const [reps, errs] = Repetition.fromRepetitionsStr(_repetitions).unwrap();
          if (errs) {
            return {
              errors: errs.map((e) => ({
                message: `${name}: 
 ${e.message}`
              }))
            };
          }
          return {
            record: RepetitionTask.of({
              name: name.replace(/^[ \t]+/, ""),
              repetitions: reps,
              baseDate: baseDate ? import_owlelia4.DateTime.of(baseDate) : void 0,
              indent: (_b = (_a2 = name.match("^[ 	]+")) == null ? void 0 : _a2.at(0)) != null ? _b : ""
            })
          };
        });
        const errors = recordOrErrors.map((x) => x.errors).filter((x) => x !== void 0).flat();
        if (errors.length > 0) {
          throw {
            name: "\u7E70\u308A\u8FD4\u3057\u30BF\u30B9\u30AF\u306E\u8AAD\u307F\u8FBC\u307F\u6642\u306B\u30D1\u30FC\u30B9\u30A8\u30E9\u30FC\u304C\u767A\u751F",
            message: errors.map((x) => `${x.message}`).join("\n")
          };
        }
        return recordOrErrors.map((x) => x.record).filter((x) => x !== void 0);
      })
    );
  }
  loadHolidays() {
    return (0, import_owlelia4.fromPromise)(
      this.holidaysFilePath ? this.appHelper.loadFile(this.holidaysFilePath).then(
        (holidaysStr) => holidaysStr.split("\n").filter((line) => !line.startsWith("//") && line.trim() !== "").map(import_owlelia4.DateTime.of).filter((x) => !Number.isNaN(x.date.getTime()))
        // TODO: owleliaに実装する
      ) : Promise.resolve([])
    );
  }
};

// src/repository/TimerRepositoryImpl.ts
var import_owlelia6 = __toESM(require_dist());

// src/domain/vo/Timer.ts
var import_owlelia5 = __toESM(require_dist());
var _brand = Symbol();
var _a;
var Timer = class _Timer extends (_a = import_owlelia5.ValueObject, _brand, _a) {
  static of(props) {
    return new _Timer(props);
  }
  stop(now3) {
    return new _Timer({
      ...this._value,
      startTime: void 0,
      accumulatedSeconds: this.getPastSeconds(now3)
    });
  }
  getPastSeconds(now3) {
    return now3.diffSeconds(this._value.startTime) + this._value.accumulatedSeconds;
  }
  get name() {
    return this._value.name;
  }
  get accumulatedSeconds() {
    return this._value.accumulatedSeconds;
  }
  get startTime() {
    return this._value.startTime;
  }
};

// src/repository/TimerRepositoryImpl.ts
var import_obsidian3 = require("obsidian");
var TimerRepositoryImpl = class {
  constructor(appHelper, timerStorageFilePath) {
    this.appHelper = appHelper;
    this.timerStorageFilePath = timerStorageFilePath;
  }
  get normalizedTimerStoragePath() {
    return (0, import_obsidian3.normalizePath)(this.timerStorageFilePath);
  }
  hasTimer() {
    return this.appHelper.exists(this.normalizedTimerStoragePath);
  }
  loadTimer() {
    return (0, import_owlelia6.fromPromise)(
      this.appHelper.loadJson(this.normalizedTimerStoragePath).then(
        (x) => Timer.of({
          name: x.name,
          accumulatedSeconds: x.accumulatedSeconds,
          startTime: x.startTime ? import_owlelia6.DateTime.of(x.startTime) : void 0
        })
      )
    );
  }
  saveTimer(timer) {
    var _a2;
    return (0, import_owlelia6.fromPromise)(
      this.appHelper.saveJson(this.normalizedTimerStoragePath, {
        name: timer.name,
        accumulatedSeconds: timer.accumulatedSeconds,
        startTime: (_a2 = timer.startTime) == null ? void 0 : _a2.unix
      })
    );
  }
  clearTimer() {
    return (0, import_owlelia6.fromPromise)(
      this.appHelper.deleteFileIfExists(this.normalizedTimerStoragePath)
    );
  }
};

// src/app/TaskServiceImpl.ts
var import_owlelia7 = __toESM(require_dist());
var TaskServiceImpl = class {
  constructor(appHelper, repository) {
    this.appHelper = appHelper;
    this.repository = repository;
  }
  serRepository(repository) {
    this.repository = repository;
  }
  async insertTasksToDailyNote(date) {
    const [tasks, err2] = (await this.loadRepetitionTasks()).unwrap();
    if (err2) {
      return err2;
    }
    const [holidays, err22] = (await this.loadHolidays()).unwrap();
    if (err22) {
      return err22;
    }
    this.appHelper.insertStringToActiveFile(
      tasks.filter((x) => x.shouldTry(date, holidays)).map((x) => x.toString()).join("\n")
    );
  }
  async loadRepetitionTasks() {
    return this.repository.loadRepetitionTasks();
  }
  async loadHolidays() {
    return this.repository.loadHolidays();
  }
  calcDatesInFuture(task2, holidays, monthsAhead) {
    const today2 = import_owlelia7.DateTime.today();
    return today2.toDate(today2.plusMonths(monthsAhead)).filter((x) => task2.shouldTry(x, holidays));
  }
};

// src/ui/RepetitionTaskItemView.ts
var import_obsidian4 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src) tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a2;
    return (_a2 = this._observer) != null ? _a2 : this._observer = new ResizeObserver((entries) => {
      var _a3;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a3 = this._listeners.get(entry.target)) == null ? void 0 : _a3(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block4, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--) old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block4(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n) insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a2;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a2 = this.$$c) == null ? void 0 : _a2.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a2;
  const type = (_a2 = props_definition[prop]) == null ? void 0 : _a2.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1) callbacks.splice(index2, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// node_modules/@event-calendar/core/index.js
function keyEnter(fn) {
  return function(e) {
    return e.key === "Enter" || e.key === " " && !e.preventDefault() ? fn.call(this, e) : void 0;
  };
}
function setContent(node, content) {
  let actions = {
    update(content2) {
      if (typeof content2 == "string") {
        node.innerText = content2;
      } else if (content2 == null ? void 0 : content2.domNodes) {
        node.replaceChildren(...content2.domNodes);
      } else if (content2 == null ? void 0 : content2.html) {
        node.innerHTML = content2.html;
      }
    }
  };
  actions.update(content);
  return actions;
}
function outsideEvent(node, type) {
  const handlePointerDown = (jsEvent) => {
    if (node && !node.contains(jsEvent.target)) {
      node.dispatchEvent(
        new CustomEvent(type + "outside", { detail: { jsEvent } })
      );
    }
  };
  document.addEventListener(type, handlePointerDown, true);
  return {
    destroy() {
      document.removeEventListener(type, handlePointerDown, true);
    }
  };
}
var DAY_IN_SECONDS = 86400;
function createDate(input = void 0) {
  if (input !== void 0) {
    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
  }
  return _fromLocalDate(/* @__PURE__ */ new Date());
}
function createDuration(input) {
  if (typeof input === "number") {
    input = { seconds: input };
  } else if (typeof input === "string") {
    let seconds = 0, exp = 2;
    for (let part of input.split(":", 3)) {
      seconds += parseInt(part, 10) * Math.pow(60, exp--);
    }
    input = { seconds };
  } else if (input instanceof Date) {
    input = { hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds() };
  }
  let weeks = input.weeks || input.week || 0;
  return {
    years: input.years || input.year || 0,
    months: input.months || input.month || 0,
    days: weeks * 7 + (input.days || input.day || 0),
    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
    inWeeks: !!weeks
  };
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function addDuration(date, duration, x = 1) {
  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
  let month = date.getUTCMonth() + x * duration.months;
  date.setUTCMonth(month);
  month %= 12;
  if (month < 0) {
    month += 12;
  }
  while (date.getUTCMonth() !== month) {
    subtractDay(date);
  }
  date.setUTCDate(date.getUTCDate() + x * duration.days);
  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
  return date;
}
function subtractDuration(date, duration, x = 1) {
  return addDuration(date, duration, -x);
}
function addDay(date, x = 1) {
  date.setUTCDate(date.getUTCDate() + x);
  return date;
}
function subtractDay(date, x = 1) {
  return addDay(date, -x);
}
function setMidnight(date) {
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function toLocalDate(date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
function toISOString(date, len = 19) {
  return date.toISOString().substring(0, len);
}
function datesEqual(date1, ...dates2) {
  return dates2.every((date2) => date1.getTime() === date2.getTime());
}
function nextClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 >= 0 ? diff2 : diff2 + 7));
  return date;
}
function prevClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 <= 0 ? diff2 : diff2 - 7));
  return date;
}
function noTimePart(date) {
  return typeof date === "string" && date.length <= 10;
}
function copyTime(toDate, fromDate) {
  toDate.setUTCHours(fromDate.getUTCHours(), fromDate.getUTCMinutes(), fromDate.getUTCSeconds(), 0);
  return toDate;
}
function _fromLocalDate(date) {
  return new Date(Date.UTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ));
}
function _fromISOString(str) {
  const parts = str.match(/\d+/g);
  return new Date(Date.UTC(
    Number(parts[0]),
    Number(parts[1]) - 1,
    Number(parts[2]),
    Number(parts[3] || 0),
    Number(parts[4] || 0),
    Number(parts[5] || 0)
  ));
}
function debounce(fn, handle, queueStore) {
  queueStore.update((queue) => queue.set(handle, fn));
}
function flushDebounce(queue) {
  run_all(queue);
  queue.clear();
}
function task(fn, handle, tasks) {
  handle != null ? handle : handle = fn;
  if (!tasks.has(handle)) {
    tasks.set(handle, setTimeout(() => {
      tasks.delete(handle);
      fn();
    }));
  }
}
function assign2(...args) {
  return Object.assign(...args);
}
function keys(object) {
  return Object.keys(object);
}
function max(...args) {
  return Math.max(...args);
}
function symbol() {
  return Symbol("ec");
}
function createElement(tag, className, content, attrs = []) {
  let el = document.createElement(tag);
  el.className = className;
  if (typeof content == "string") {
    el.innerText = content;
  } else if (content.domNodes) {
    el.replaceChildren(...content.domNodes);
  } else if (content.html) {
    el.innerHTML = content.html;
  }
  for (let attr2 of attrs) {
    el.setAttribute(...attr2);
  }
  return el;
}
function hasYScroll(el) {
  return el.scrollHeight > el.clientHeight;
}
function rect(el) {
  return el.getBoundingClientRect();
}
function ancestor(el, up) {
  while (up--) {
    el = el.parentElement;
  }
  return el;
}
function height(el) {
  return rect(el).height;
}
var payloadProp = symbol();
function setPayload(el, payload) {
  el[payloadProp] = payload;
}
function hasPayload(el) {
  return !!(el == null ? void 0 : el[payloadProp]);
}
function getPayload(el) {
  return el[payloadProp];
}
function getElementWithPayload(x, y, root = document) {
  for (let el of root.elementsFromPoint(x, y)) {
    if (hasPayload(el)) {
      return el;
    }
    if (el.shadowRoot) {
      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
      if (shadowEl) {
        return shadowEl;
      }
    }
  }
  return null;
}
function createView(view2, _viewTitle, _currentRange, _activeRange) {
  return {
    type: view2,
    title: _viewTitle,
    currentStart: _currentRange.start,
    currentEnd: _currentRange.end,
    activeStart: _activeRange.start,
    activeEnd: _activeRange.end,
    calendar: void 0
  };
}
function toViewWithLocalDates(view2) {
  view2 = assign2({}, view2);
  view2.currentStart = toLocalDate(view2.currentStart);
  view2.currentEnd = toLocalDate(view2.currentEnd);
  view2.activeStart = toLocalDate(view2.activeStart);
  view2.activeEnd = toLocalDate(view2.activeEnd);
  return view2;
}
function listView(view2) {
  return view2.startsWith("list");
}
var eventId = 1;
function createEvents(input) {
  return input.map((event) => {
    var _a2;
    return {
      id: "id" in event ? String(event.id) : `{generated-${eventId++}}`,
      resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : "resourceId" in event ? [String(event.resourceId)] : [],
      allDay: (_a2 = event.allDay) != null ? _a2 : noTimePart(event.start) && noTimePart(event.end),
      start: createDate(event.start),
      end: createDate(event.end),
      title: event.title || "",
      titleHTML: event.titleHTML || "",
      editable: event.editable,
      startEditable: event.startEditable,
      durationEditable: event.durationEditable,
      display: event.display || "auto",
      extendedProps: event.extendedProps || {},
      backgroundColor: event.backgroundColor || event.color,
      textColor: event.textColor
    };
  });
}
function createEventSources(input) {
  return input.map((source) => ({
    events: source.events,
    url: source.url && source.url.trimEnd("&") || "",
    method: source.method && source.method.toUpperCase() || "GET",
    extraParams: source.extraParams || {}
  }));
}
function createEventChunk(event, start, end) {
  return {
    start: event.start > start ? event.start : start,
    end: event.end < end ? event.end : end,
    event
  };
}
function sortEventChunks(chunks) {
  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
}
function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
  let timeText = _intlEventTime.formatRange(
    chunk.start,
    displayEventEnd && chunk.event.display !== "pointer" ? copyTime(cloneDate(chunk.start), chunk.end) : chunk.start
  );
  let content;
  if (eventContent) {
    content = is_function(eventContent) ? eventContent({
      event: toEventWithLocalDates(chunk.event),
      timeText,
      view: toViewWithLocalDates(_view)
    }) : eventContent;
  } else {
    let domNodes;
    switch (chunk.event.display) {
      case "background":
        domNodes = [];
        break;
      case "pointer":
        domNodes = [createTimeElement(timeText, chunk, theme)];
        break;
      default:
        domNodes = [
          ...chunk.event.allDay ? [] : [createTimeElement(timeText, chunk, theme)],
          createElement("h4", theme.eventTitle, chunk.event.title)
        ];
    }
    content = { domNodes };
  }
  return [timeText, content];
}
function createTimeElement(timeText, chunk, theme) {
  return createElement(
    "time",
    theme.eventTime,
    timeText,
    [["datetime", toISOString(chunk.start)]]
  );
}
function createEventClasses(eventClassNames, event, _view) {
  if (eventClassNames) {
    if (is_function(eventClassNames)) {
      eventClassNames = eventClassNames({
        event: toEventWithLocalDates(event),
        view: toViewWithLocalDates(_view)
      });
    }
    return Array.isArray(eventClassNames) ? eventClassNames : [eventClassNames];
  }
  return [];
}
function toEventWithLocalDates(event) {
  return _cloneEvent(event, toLocalDate);
}
function _cloneEvent(event, dateFn) {
  event = assign2({}, event);
  event.start = dateFn(event.start);
  event.end = dateFn(event.end);
  return event;
}
function prepareEventChunks(chunks, hiddenDays) {
  let longChunks = {};
  if (chunks.length) {
    sortEventChunks(chunks);
    let prevChunk;
    for (let chunk of chunks) {
      let dates = [];
      let date = setMidnight(cloneDate(chunk.start));
      while (chunk.end > date) {
        if (!hiddenDays.includes(date.getUTCDay())) {
          dates.push(cloneDate(date));
          if (dates.length > 1) {
            let key = date.getTime();
            if (longChunks[key]) {
              longChunks[key].chunks.push(chunk);
            } else {
              longChunks[key] = {
                sorted: false,
                chunks: [chunk]
              };
            }
          }
        }
        addDay(date);
      }
      if (dates.length) {
        chunk.date = dates[0];
        chunk.days = dates.length;
        chunk.dates = dates;
        if (chunk.start < dates[0]) {
          chunk.start = dates[0];
        }
        if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
          chunk.end = dates[dates.length - 1];
        }
      } else {
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        chunk.dates = [chunk.date];
      }
      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
        chunk.prev = prevChunk;
      }
      prevChunk = chunk;
    }
  }
  return longChunks;
}
function repositionEvent(chunk, longChunks, height2) {
  var _a2, _b;
  chunk.top = 0;
  if (chunk.prev) {
    chunk.top = chunk.prev.bottom + 1;
  }
  chunk.bottom = chunk.top + height2;
  let margin = 1;
  let key = chunk.date.getTime();
  if (((_a2 = longChunks[key]) == null ? void 0 : _a2.sorted) || ((_b = longChunks[key]) == null ? void 0 : _b.chunks.every((chunk2) => "top" in chunk2))) {
    if (!longChunks[key].sorted) {
      longChunks[key].chunks.sort((a, b) => a.top - b.top);
      longChunks[key].sorted = true;
    }
    for (let longChunk of longChunks[key].chunks) {
      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
        let offset = longChunk.bottom - chunk.top + 1;
        margin += offset;
        chunk.top += offset;
        chunk.bottom += offset;
      }
    }
  }
  return margin;
}
function runReposition(refs, data) {
  var _a2;
  refs.length = data.length;
  for (let ref of refs) {
    (_a2 = ref == null ? void 0 : ref.reposition) == null ? void 0 : _a2.call(ref);
  }
}
function eventIntersects(event, start, end, resource, timeMode) {
  return (event.start < end && event.end > start || !timeMode && datesEqual(event.start, event.end, start)) && (resource === void 0 || event.resourceIds.includes(resource.id));
}
function helperEvent(display) {
  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
}
function bgEvent(display) {
  return display === "background";
}
function previewEvent(display) {
  return display === "preview";
}
function ghostEvent(display) {
  return display === "ghost";
}
function pointerEvent(display) {
  return display === "pointer";
}
function btnTextMonth(text2) {
  return btnText(text2, "month");
}
function btnText(text2, period) {
  return {
    ...text2,
    next: "Next " + period,
    prev: "Previous " + period
  };
}
function themeView(view2) {
  return (theme) => ({ ...theme, view: view2 });
}
function intl(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let intl2 = is_function($format) ? { format: $format } : new Intl.DateTimeFormat($locale, $format);
    return {
      format: (date) => intl2.format(toLocalDate(date))
    };
  });
}
function intlRange(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let formatRange;
    if (is_function($format)) {
      formatRange = $format;
    } else {
      let intl2 = new Intl.DateTimeFormat($locale, $format);
      formatRange = (start, end) => {
        if (start <= end) {
          return intl2.formatRange(start, end);
        } else {
          let parts = intl2.formatRangeToParts(end, start);
          let result = "";
          let sources = ["startRange", "endRange"];
          let processed = [false, false];
          for (let part of parts) {
            let i = sources.indexOf(part.source);
            if (i >= 0) {
              if (!processed[i]) {
                result += _getParts(sources[1 - i], parts);
                processed[i] = true;
              }
            } else {
              result += part.value;
            }
          }
          return result;
        }
      };
    }
    return {
      formatRange: (start, end) => formatRange(toLocalDate(start), toLocalDate(end))
    };
  });
}
function _getParts(source, parts) {
  let result = "";
  for (let part of parts) {
    if (part.source == source) {
      result += part.value;
    }
  }
  return result;
}
function createOptions(plugins) {
  var _a2;
  let options = {
    allDayContent: void 0,
    allDaySlot: true,
    buttonText: {
      today: "today"
    },
    customButtons: {},
    date: /* @__PURE__ */ new Date(),
    datesSet: void 0,
    dayHeaderFormat: {
      weekday: "short",
      month: "numeric",
      day: "numeric"
    },
    dayHeaderAriaLabelFormat: {
      dateStyle: "long"
    },
    displayEventEnd: true,
    duration: { weeks: 1 },
    events: [],
    eventAllUpdated: void 0,
    eventBackgroundColor: void 0,
    eventTextColor: void 0,
    eventClassNames: void 0,
    eventClick: void 0,
    eventColor: void 0,
    eventContent: void 0,
    eventDidMount: void 0,
    eventMouseEnter: void 0,
    eventMouseLeave: void 0,
    eventSources: [],
    eventTimeFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    firstDay: 0,
    flexibleSlotTimeLimits: false,
    // ec option
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    height: void 0,
    hiddenDays: [],
    highlightedDates: [],
    // ec option
    lazyFetching: true,
    loading: void 0,
    locale: void 0,
    nowIndicator: false,
    selectable: false,
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    slotEventOverlap: true,
    slotHeight: 24,
    // ec option
    slotLabelFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    slotMaxTime: "24:00:00",
    slotMinTime: "00:00:00",
    theme: {
      allDay: "ec-all-day",
      active: "ec-active",
      bgEvent: "ec-bg-event",
      bgEvents: "ec-bg-events",
      body: "ec-body",
      button: "ec-button",
      buttonGroup: "ec-button-group",
      calendar: "ec",
      compact: "ec-compact",
      content: "ec-content",
      day: "ec-day",
      dayHead: "ec-day-head",
      days: "ec-days",
      event: "ec-event",
      eventBody: "ec-event-body",
      eventTime: "ec-event-time",
      eventTitle: "ec-event-title",
      events: "ec-events",
      extra: "ec-extra",
      handle: "ec-handle",
      header: "ec-header",
      hiddenScroll: "ec-hidden-scroll",
      highlight: "ec-highlight",
      icon: "ec-icon",
      line: "ec-line",
      lines: "ec-lines",
      nowIndicator: "ec-now-indicator",
      otherMonth: "ec-other-month",
      sidebar: "ec-sidebar",
      sidebarTitle: "ec-sidebar-title",
      today: "ec-today",
      time: "ec-time",
      title: "ec-title",
      toolbar: "ec-toolbar",
      view: "",
      weekdays: ["ec-sun", "ec-mon", "ec-tue", "ec-wed", "ec-thu", "ec-fri", "ec-sat"],
      withScroll: "ec-with-scroll"
    },
    titleFormat: {
      year: "numeric",
      month: "short",
      day: "numeric"
    },
    view: void 0,
    viewDidMount: void 0,
    views: {}
  };
  for (let plugin of plugins) {
    (_a2 = plugin.createOptions) == null ? void 0 : _a2.call(plugin, options);
  }
  return options;
}
function createParsers(plugins) {
  var _a2;
  let parsers = {
    date: (date) => setMidnight(createDate(date)),
    duration: createDuration,
    events: createEvents,
    eventSources: createEventSources,
    hiddenDays: (days2) => [...new Set(days2)],
    highlightedDates: (dates) => dates.map(createDate),
    scrollTime: createDuration,
    slotDuration: createDuration,
    slotMaxTime: createDuration,
    slotMinTime: createDuration
  };
  for (let plugin of plugins) {
    (_a2 = plugin.createParsers) == null ? void 0 : _a2.call(plugin, parsers);
  }
  return parsers;
}
function diff(options, prevOptions) {
  let diff2 = [];
  for (let key of keys(options)) {
    if (options[key] !== prevOptions[key]) {
      diff2.push([key, options[key]]);
    }
  }
  assign2(prevOptions, options);
  return diff2;
}
function dayGrid(state) {
  return derived(state.view, ($view) => $view == null ? void 0 : $view.startsWith("dayGrid"));
}
function activeRange(state) {
  return derived(
    [state._currentRange, state.firstDay, state.slotMaxTime, state._dayGrid],
    ([$_currentRange, $firstDay, $slotMaxTime, $_dayGrid]) => {
      let start = cloneDate($_currentRange.start);
      let end = cloneDate($_currentRange.end);
      if ($_dayGrid) {
        prevClosestDay(start, $firstDay);
        nextClosestDay(end, $firstDay);
      } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
        addDuration(subtractDay(end), $slotMaxTime);
        let start2 = subtractDay(cloneDate(end));
        if (start2 < start) {
          start = start2;
        }
      }
      return { start, end };
    }
  );
}
function currentRange(state) {
  return derived(
    [state.date, state.duration, state.firstDay, state._dayGrid],
    ([$date, $duration, $firstDay, $_dayGrid]) => {
      let start = cloneDate($date), end;
      if ($_dayGrid) {
        start.setUTCDate(1);
      } else if ($duration.inWeeks) {
        prevClosestDay(start, $firstDay);
      }
      end = addDuration(cloneDate(start), $duration);
      return { start, end };
    }
  );
}
function viewDates(state) {
  return derived([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
    let dates = [];
    let date = setMidnight(cloneDate($_activeRange.start));
    let end = setMidnight(cloneDate($_activeRange.end));
    while (date < end) {
      if (!$hiddenDays.includes(date.getUTCDay())) {
        dates.push(cloneDate(date));
      }
      addDay(date);
    }
    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
      state.date.update((date2) => {
        while ($hiddenDays.includes(date2.getUTCDay())) {
          addDay(date2);
        }
        return date2;
      });
      dates = get_store_value(state._viewDates);
    }
    return dates;
  });
}
function viewTitle(state) {
  return derived(
    [state.date, state._activeRange, state._intlTitle, state._dayGrid],
    ([$date, $_activeRange, $_intlTitle, $_dayGrid]) => {
      return $_dayGrid ? $_intlTitle.formatRange($date, $date) : $_intlTitle.formatRange($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
    }
  );
}
function view(state) {
  return derived([state.view, state._viewTitle, state._currentRange, state._activeRange], (args) => createView(...args));
}
function events(state) {
  let _events = writable([]);
  let abortController;
  let fetching = 0;
  let debounceHandle = {};
  derived(
    [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
    (values, set) => debounce(() => {
      let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
      if (!$eventSources.length) {
        set($events);
        return;
      }
      if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        if (is_function($loading) && !fetching) {
          $loading(true);
        }
        let stopLoading = () => {
          if (--fetching === 0 && is_function($loading)) {
            $loading(false);
          }
        };
        let events2 = [];
        let failure = (e) => stopLoading();
        let success = (data) => {
          events2 = events2.concat(createEvents(data));
          set(events2);
          stopLoading();
        };
        let startStr = toISOString($_activeRange.start);
        let endStr = toISOString($_activeRange.end);
        for (let source of $eventSources) {
          if (is_function(source.events)) {
            let result = source.events({
              start: toLocalDate($_activeRange.start),
              end: toLocalDate($_activeRange.end),
              startStr,
              endStr
            }, success, failure);
            if (result !== void 0) {
              Promise.resolve(result).then(success, failure);
            }
          } else {
            let params = is_function(source.extraParams) ? source.extraParams() : assign2({}, source.extraParams);
            params.start = startStr;
            params.end = endStr;
            params = new URLSearchParams(params);
            let url = source.url, headers = {}, body;
            if (["GET", "HEAD"].includes(source.method)) {
              url += (url.includes("?") ? "&" : "?") + params;
            } else {
              headers["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8";
              body = String(params);
            }
            fetch(url, { method: source.method, headers, body, signal: abortController.signal, credentials: "same-origin" }).then((response) => response.json()).then(success).catch(failure);
          }
          ++fetching;
        }
        $_fetchedRange.start = $_activeRange.start;
        $_fetchedRange.end = $_activeRange.end;
      }
    }, debounceHandle, state._queue),
    []
  ).subscribe(_events.set);
  return _events;
}
function now2() {
  return readable(createDate(), (set) => {
    let interval = setInterval(() => {
      set(createDate());
    }, 1e3);
    return () => clearInterval(interval);
  });
}
function today(state) {
  return derived(state._now, ($_now) => setMidnight(cloneDate($_now)));
}
var State = class {
  constructor(plugins, input) {
    var _a2, _b, _c, _d, _e;
    plugins = plugins || [];
    let options = createOptions(plugins);
    let parsers = createParsers(plugins);
    options = parseOpts(options, parsers);
    input = parseOpts(input, parsers);
    for (let [option, value] of Object.entries(options)) {
      this[option] = writable(value);
    }
    this._queue = writable(/* @__PURE__ */ new Map());
    this._queue2 = writable(/* @__PURE__ */ new Map());
    this._tasks = /* @__PURE__ */ new Map();
    this._auxiliary = writable([]);
    this._dayGrid = dayGrid(this);
    this._currentRange = currentRange(this);
    this._activeRange = activeRange(this);
    this._fetchedRange = writable({ start: void 0, end: void 0 });
    this._events = events(this);
    this._now = now2();
    this._today = today(this);
    this._intlEventTime = intlRange(this.locale, this.eventTimeFormat);
    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
    this._intlDayHeaderAL = intl(this.locale, this.dayHeaderAriaLabelFormat);
    this._intlTitle = intlRange(this.locale, this.titleFormat);
    this._bodyEl = writable(void 0);
    this._scrollable = writable(false);
    this._viewTitle = viewTitle(this);
    this._viewDates = viewDates(this);
    this._view = view(this);
    this._viewComponent = writable(void 0);
    this._resBgColor = writable(noop);
    this._resTxtColor = writable(noop);
    this._interaction = writable({});
    this._iEvents = writable([null, null]);
    this._iClasses = writable(identity);
    this._iClass = writable(void 0);
    this._set = (key, value) => {
      if (validKey(key, this)) {
        if (parsers[key]) {
          value = parsers[key](value);
        }
        this[key].set(value);
      }
    };
    this._get = (key) => validKey(key, this) ? get_store_value(this[key]) : void 0;
    for (let plugin of plugins) {
      (_a2 = plugin.createStores) == null ? void 0 : _a2.call(plugin, this);
    }
    if (input.view) {
      this.view.set(input.view);
    }
    let views = /* @__PURE__ */ new Set([...keys(options.views), ...keys((_b = input.views) != null ? _b : {})]);
    for (let view2 of views) {
      let defOpts = mergeOpts(options, (_c = options.views[view2]) != null ? _c : {});
      let opts = mergeOpts(defOpts, input, (_e = (_d = input.views) == null ? void 0 : _d[view2]) != null ? _e : {});
      let component = opts.component;
      filterOpts(opts, this);
      for (let key of keys(opts)) {
        let { set, _set = set, ...rest } = this[key];
        this[key] = {
          // Set value in all views
          set: ["buttonText", "theme"].includes(key) ? (value) => {
            if (is_function(value)) {
              let result = value(defOpts[key]);
              opts[key] = result;
              set(set === _set ? result : value);
            } else {
              opts[key] = value;
              set(value);
            }
          } : (value) => {
            opts[key] = value;
            set(value);
          },
          _set,
          ...rest
        };
      }
      this.view.subscribe((newView) => {
        if (newView === view2) {
          this._viewComponent.set(component);
          if (is_function(opts.viewDidMount)) {
            tick().then(() => opts.viewDidMount(get_store_value(this._view)));
          }
          for (let key of keys(opts)) {
            this[key]._set(opts[key]);
          }
        }
      });
    }
  }
};
function parseOpts(opts, parsers) {
  let result = { ...opts };
  for (let key of keys(parsers)) {
    if (key in result) {
      result[key] = parsers[key](result[key]);
    }
  }
  if (opts.views) {
    result.views = {};
    for (let view2 of keys(opts.views)) {
      result.views[view2] = parseOpts(opts.views[view2], parsers);
    }
  }
  return result;
}
function mergeOpts(...args) {
  let result = {};
  for (let opts of args) {
    let override = {};
    for (let key of ["buttonText", "theme"]) {
      if (is_function(opts[key])) {
        override[key] = opts[key](result[key]);
      }
    }
    result = {
      ...result,
      ...opts,
      ...override
    };
  }
  return result;
}
function filterOpts(opts, state) {
  keys(opts).filter((key) => !validKey(key, state) || key == "view").forEach((key) => delete opts[key]);
}
function validKey(key, state) {
  return state.hasOwnProperty(key) && key[0] !== "_";
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[22](
        /*button*/
        ctx[25]
      )
    );
  }
  return {
    c() {
      button_1 = element("button");
      t = text(t_value);
      attr(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25]);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t);
      if (!mounted) {
        dispose = listen(button_1, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx[5][
        /*button*/
        ctx[25]
      ] + "")) set_data(t, t_value);
      if (dirty & /*$theme, $view, buttons*/
      137 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25])) {
        attr(button_1, "class", button_1_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4(ctx) {
  let button_1;
  let t_value = (
    /*$customButtons*/
    ctx[6][
      /*button*/
      ctx[25]
    ].text + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t = text(t_value);
      attr(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t);
      if (!mounted) {
        dispose = listen(button_1, "click", function() {
          if (is_function(
            /*$customButtons*/
            ctx[6][
              /*button*/
              ctx[25]
            ].click
          )) ctx[6][
            /*button*/
            ctx[25]
          ].click.apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$customButtons, buttons*/
      65 && t_value !== (t_value = /*$customButtons*/
      ctx[6][
        /*button*/
        ctx[25]
      ].text + "")) set_data(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25])) {
        attr(button_1, "class", button_1_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      t = text(t_value);
      attr(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      button_1.disabled = /*isToday*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, t);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*click_handler*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx2[5][
        /*button*/
        ctx2[25]
      ] + "")) set_data(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*isToday*/
      2) {
        button_1.disabled = /*isToday*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      i = element("i");
      attr(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      attr(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].next);
      attr(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].next);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, i);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*next*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].next)) {
        attr(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].next)) {
        attr(button_1, "title", button_1_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button_1 = element("button");
      i = element("i");
      attr(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      attr(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].prev);
      attr(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].prev);
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, i);
      if (!mounted) {
        dispose = listen(
          button_1,
          "click",
          /*prev*/
          ctx[18]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr(button_1, "title", button_1_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1(ctx) {
  let h2;
  let h2_class_value;
  let setContent_action;
  let mounted;
  let dispose;
  return {
    c() {
      h2 = element("h2");
      attr(h2, "class", h2_class_value = /*$theme*/
      ctx[3].title);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          h2,
          /*$_viewTitle*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$theme*/
      8 && h2_class_value !== (h2_class_value = /*$theme*/
      ctx2[3].title)) {
        attr(h2, "class", h2_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_viewTitle*/
      16) setContent_action.update.call(
        null,
        /*$_viewTitle*/
        ctx2[4]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[25] == "title"
    ) return create_if_block$1;
    if (
      /*button*/
      ctx2[25] == "prev"
    ) return create_if_block_1;
    if (
      /*button*/
      ctx2[25] == "next"
    ) return create_if_block_2;
    if (
      /*button*/
      ctx2[25] == "today"
    ) return create_if_block_3;
    if (
      /*$customButtons*/
      ctx2[6][
        /*button*/
        ctx2[25]
      ]
    ) return create_if_block_4;
    if (
      /*button*/
      ctx2[25] != ""
    ) return create_if_block_5;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_fragment$3(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*buttons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$theme, $_viewTitle, buttons, $buttonText, prev, next, isToday, $date, today, $customButtons, $view*/
      917759) {
        each_value = ensure_array_like(
          /*buttons*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $duration;
  let $date;
  let $hiddenDays;
  let $_currentRange;
  let $theme;
  let $_viewTitle;
  let $buttonText;
  let $customButtons;
  let $view;
  let { buttons } = $$props;
  let { _currentRange, _viewTitle, buttonText, customButtons, date, duration, hiddenDays, theme, view: view2 } = getContext("state");
  component_subscribe($$self, _currentRange, (value) => $$invalidate(20, $_currentRange = value));
  component_subscribe($$self, _viewTitle, (value) => $$invalidate(4, $_viewTitle = value));
  component_subscribe($$self, buttonText, (value) => $$invalidate(5, $buttonText = value));
  component_subscribe($$self, customButtons, (value) => $$invalidate(6, $customButtons = value));
  component_subscribe($$self, date, (value) => $$invalidate(2, $date = value));
  component_subscribe($$self, duration, (value) => $$invalidate(23, $duration = value));
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(24, $hiddenDays = value));
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  component_subscribe($$self, view2, (value) => $$invalidate(7, $view = value));
  let today2 = setMidnight(createDate()), isToday;
  function prev() {
    let d = subtractDuration($date, $duration);
    if ($hiddenDays.length && $hiddenDays.length < 7) {
      while ($hiddenDays.includes(d.getUTCDay())) {
        subtractDay(d);
      }
    }
    set_store_value(date, $date = d, $date);
  }
  function next() {
    set_store_value(date, $date = addDuration($date, $duration), $date);
  }
  const click_handler = () => set_store_value(date, $date = cloneDate(today2), $date);
  const click_handler_1 = (button) => set_store_value(view2, $view = button, $view);
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2) $$invalidate(0, buttons = $$props2.buttons);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_currentRange*/
    1048576) {
      $$invalidate(1, isToday = today2 >= $_currentRange.start && today2 < $_currentRange.end || null);
    }
  };
  return [
    buttons,
    isToday,
    $date,
    $theme,
    $_viewTitle,
    $buttonText,
    $customButtons,
    $view,
    _currentRange,
    _viewTitle,
    buttonText,
    customButtons,
    date,
    duration,
    hiddenDays,
    theme,
    view2,
    today2,
    prev,
    next,
    $_currentRange,
    click_handler,
    click_handler_1
  ];
}
var Buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { buttons: 0 });
  }
};
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let buttons_1;
  let current;
  buttons_1 = new Buttons({ props: { buttons: (
    /*buttons*/
    ctx[8]
  ) } });
  return {
    c() {
      create_component(buttons_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttons_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1) buttons_1_changes.buttons = /*buttons*/
      ctx2[8];
      buttons_1.$set(buttons_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttons_1, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let buttons_1;
  let div_class_value;
  let current;
  buttons_1 = new Buttons({ props: { buttons: (
    /*buttons*/
    ctx[8]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(buttons_1.$$.fragment);
      attr(div, "class", div_class_value = /*$theme*/
      ctx[1].buttonGroup);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(buttons_1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1) buttons_1_changes.buttons = /*buttons*/
      ctx2[8];
      buttons_1.$set(buttons_1_changes);
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].buttonGroup)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(buttons_1);
    }
  };
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttons*/
      ctx2[8].length > 1
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block$1(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*sections*/
    ctx[0][
      /*key*/
      ctx[5]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$theme, sections, Object*/
      3) {
        each_value_1 = ensure_array_like(
          /*sections*/
          ctx2[0][
            /*key*/
            ctx2[5]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let nav;
  let nav_class_value;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*sections*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(nav, "class", nav_class_value = /*$theme*/
      ctx[1].toolbar);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(nav, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*sections, Object, $theme*/
      3) {
        each_value = ensure_array_like(Object.keys(
          /*sections*/
          ctx2[0]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(nav, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      2 && nav_class_value !== (nav_class_value = /*$theme*/
      ctx2[1].toolbar)) {
        attr(nav, "class", nav_class_value);
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $headerToolbar;
  let $theme;
  let { headerToolbar, theme } = getContext("state");
  component_subscribe($$self, headerToolbar, (value) => $$invalidate(4, $headerToolbar = value));
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  let sections = { start: [], center: [], end: [] };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections, $headerToolbar*/
    17) {
      {
        for (let key of Object.keys(sections)) {
          $$invalidate(0, sections[key] = $headerToolbar[key].split(" ").map((group) => group.split(",")), sections);
        }
      }
    }
  };
  return [sections, $theme, headerToolbar, theme, $headerToolbar];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
  }
};
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*component*/
    ctx[11]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$_auxiliary*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$_auxiliary*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$_auxiliary*/
      1) {
        each_value = ensure_array_like(
          /*$_auxiliary*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $_view;
  let $datesSet;
  let $_activeRange;
  let $_auxiliary;
  let { datesSet, _auxiliary, _activeRange, _queue, _view } = getContext("state");
  component_subscribe($$self, datesSet, (value) => $$invalidate(7, $datesSet = value));
  component_subscribe($$self, _auxiliary, (value) => $$invalidate(0, $_auxiliary = value));
  component_subscribe($$self, _activeRange, (value) => $$invalidate(5, $_activeRange = value));
  component_subscribe($$self, _view, (value) => $$invalidate(6, $_view = value));
  let debounceHandle = {};
  function runDatesSet(_activeRange2) {
    if (is_function($datesSet)) {
      debounce(
        () => $datesSet({
          start: toLocalDate(_activeRange2.start),
          end: toLocalDate(_activeRange2.end),
          startStr: toISOString(_activeRange2.start),
          endStr: toISOString(_activeRange2.end),
          view: toViewWithLocalDates($_view)
        }),
        debounceHandle,
        _queue
      );
    }
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_activeRange*/
    32) {
      runDatesSet($_activeRange);
    }
  };
  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
}
var Auxiliary = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
};
function create_fragment(ctx) {
  let div;
  let toolbar;
  let t0;
  let switch_instance;
  let div_class_value;
  let div_role_value;
  let t1;
  let auxiliary;
  let current;
  let mounted;
  let dispose;
  toolbar = new Toolbar({});
  var switch_value = (
    /*$_viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  auxiliary = new Auxiliary({});
  return {
    c() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t0 = space();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(auxiliary.$$.fragment);
      attr(div, "class", div_class_value = /*$theme*/
      ctx[1].calendar + " " + /*$theme*/
      ctx[1].view + /*$_scrollable*/
      (ctx[0] ? " " + /*$theme*/
      ctx[1].withScroll : "") + /*$_iClass*/
      (ctx[2] ? " " + /*$theme*/
      ctx[1][
        /*$_iClass*/
        ctx[2]
      ] : ""));
      attr(div, "role", div_role_value = listView(
        /*$view*/
        ctx[4]
      ) ? "list" : "table");
      set_style(
        div,
        "height",
        /*$height*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(toolbar, div, null);
      append(div, t0);
      if (switch_instance) mount_component(switch_instance, div, null);
      insert(target, t1, anchor);
      mount_component(auxiliary, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "resize",
          /*recheckScrollable*/
          ctx[17]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$_viewComponent*/
      32 && switch_value !== (switch_value = /*$_viewComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
      if (!current || dirty[0] & /*$theme, $_scrollable, $_iClass*/
      7 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].calendar + " " + /*$theme*/
      ctx2[1].view + /*$_scrollable*/
      (ctx2[0] ? " " + /*$theme*/
      ctx2[1].withScroll : "") + /*$_iClass*/
      (ctx2[2] ? " " + /*$theme*/
      ctx2[1][
        /*$_iClass*/
        ctx2[2]
      ] : ""))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$view*/
      16 && div_role_value !== (div_role_value = listView(
        /*$view*/
        ctx2[4]
      ) ? "list" : "table")) {
        attr(div, "role", div_role_value);
      }
      if (dirty[0] & /*$height*/
      8) {
        set_style(
          div,
          "height",
          /*$height*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(toolbar.$$.fragment, local);
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      transition_in(auxiliary.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      transition_out(auxiliary.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
      }
      destroy_component(toolbar);
      if (switch_instance) destroy_component(switch_instance);
      destroy_component(auxiliary, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $_bodyEl;
  let $_scrollable;
  let $_queue2;
  let $_queue;
  let $_interaction;
  let $_events;
  let $theme;
  let $_iClass;
  let $height;
  let $view;
  let $_viewComponent;
  let { plugins = [] } = $$props;
  let { options = {} } = $$props;
  let component = get_current_component();
  let state = new State(plugins, options);
  setContext("state", state);
  let { _viewComponent, _bodyEl, _interaction, _iClass, _events, _queue, _queue2, _tasks, _scrollable, height: height2, theme, view: view2 } = state;
  component_subscribe($$self, _viewComponent, (value) => $$invalidate(5, $_viewComponent = value));
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(32, $_bodyEl = value));
  component_subscribe($$self, _interaction, (value) => $$invalidate(35, $_interaction = value));
  component_subscribe($$self, _iClass, (value) => $$invalidate(2, $_iClass = value));
  component_subscribe($$self, _events, (value) => $$invalidate(36, $_events = value));
  component_subscribe($$self, _queue, (value) => $$invalidate(34, $_queue = value));
  component_subscribe($$self, _queue2, (value) => $$invalidate(33, $_queue2 = value));
  component_subscribe($$self, _scrollable, (value) => $$invalidate(0, $_scrollable = value));
  component_subscribe($$self, height2, (value) => $$invalidate(3, $height = value));
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  component_subscribe($$self, view2, (value) => $$invalidate(4, $view = value));
  let prevOptions = { ...options };
  function setOption(name, value) {
    state._set(name, value);
    return this;
  }
  function getOption(name) {
    let value = state._get(name);
    return value instanceof Date ? toLocalDate(value) : value;
  }
  function refetchEvents() {
    state._fetchedRange.set({ start: void 0, end: void 0 });
    return this;
  }
  function getEvents() {
    return $_events.map(toEventWithLocalDates);
  }
  function getEventById(id) {
    for (let event of $_events) {
      if (event.id == id) {
        return toEventWithLocalDates(event);
      }
    }
    return null;
  }
  function addEvent(event) {
    $_events.push(createEvents([event])[0]);
    _events.set($_events);
    return this;
  }
  function updateEvent(event) {
    for (let e of $_events) {
      if (e.id == event.id) {
        assign2(e, createEvents([event])[0]);
        _events.set($_events);
        break;
      }
    }
    return this;
  }
  function removeEventById(id) {
    let idx = $_events.findIndex((event) => event.id == id);
    if (idx >= 0) {
      $_events.splice(idx, 1);
      _events.set($_events);
    }
    return this;
  }
  function getView() {
    return toViewWithLocalDates(get_store_value(state._view));
  }
  function unselect() {
    if ($_interaction.action) {
      $_interaction.action.unselect();
    }
    return this;
  }
  function dateFromPoint(x, y) {
    let dayEl = getElementWithPayload(x, y);
    return dayEl ? getPayload(dayEl)(y) : null;
  }
  function destroy() {
    destroy_component(component, true);
  }
  beforeUpdate(() => {
    flushDebounce($_queue);
  });
  afterUpdate(() => {
    flushDebounce($_queue2);
    task(recheckScrollable, null, _tasks);
  });
  function recheckScrollable() {
    if ($_bodyEl) {
      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("plugins" in $$props2) $$invalidate(18, plugins = $$props2.plugins);
    if ("options" in $$props2) $$invalidate(19, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    524288) {
      for (let [name, value] of diff(options, prevOptions)) {
        setOption(name, value);
      }
    }
  };
  return [
    $_scrollable,
    $theme,
    $_iClass,
    $height,
    $view,
    $_viewComponent,
    _viewComponent,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _queue2,
    _scrollable,
    height2,
    theme,
    view2,
    recheckScrollable,
    plugins,
    options,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    destroy
  ];
}
var Calendar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        plugins: 18,
        options: 19,
        setOption: 20,
        getOption: 21,
        refetchEvents: 22,
        getEvents: 23,
        getEventById: 24,
        addEvent: 25,
        updateEvent: 26,
        removeEventById: 27,
        getView: 28,
        unselect: 29,
        dateFromPoint: 30,
        destroy: 31
      },
      null,
      [-1, -1]
    );
  }
  get setOption() {
    return this.$$.ctx[20];
  }
  get getOption() {
    return this.$$.ctx[21];
  }
  get refetchEvents() {
    return this.$$.ctx[22];
  }
  get getEvents() {
    return this.$$.ctx[23];
  }
  get getEventById() {
    return this.$$.ctx[24];
  }
  get addEvent() {
    return this.$$.ctx[25];
  }
  get updateEvent() {
    return this.$$.ctx[26];
  }
  get removeEventById() {
    return this.$$.ctx[27];
  }
  get getView() {
    return this.$$.ctx[28];
  }
  get unselect() {
    return this.$$.ctx[29];
  }
  get dateFromPoint() {
    return this.$$.ctx[30];
  }
  get destroy() {
    return this.$$.ctx[31];
  }
};

// node_modules/@event-calendar/day-grid/index.js
function days(state) {
  return derived([state.date, state.firstDay, state.hiddenDays], ([$date, $firstDay, $hiddenDays]) => {
    let days2 = [];
    let day = cloneDate($date);
    let max2 = 7;
    while (day.getUTCDay() !== $firstDay && max2) {
      subtractDay(day);
      --max2;
    }
    for (let i = 0; i < 7; ++i) {
      if (!$hiddenDays.includes(day.getUTCDay())) {
        days2.push(cloneDate(day));
      }
      addDay(day);
    }
    return days2;
  });
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block$4(ctx) {
  let div;
  let span;
  let span_aria_label_value;
  let setContent_action;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      var _a2;
      div = element("div");
      span = element("span");
      t = space();
      attr(span, "aria-label", span_aria_label_value = /*$_intlDayHeaderAL*/
      ctx[2].format(
        /*day*/
        ctx[8]
      ));
      attr(div, "class", div_class_value = /*$theme*/
      ctx[0].day + " " + /*$theme*/
      ((_a2 = ctx[0].weekdays) == null ? void 0 : _a2[
        /*day*/
        ctx[8].getUTCDay()
      ]));
      attr(div, "role", "columnheader");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t);
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          span,
          /*$_intlDayHeader*/
          ctx[3].format(
            /*day*/
            ctx[8]
          )
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (dirty & /*$_intlDayHeaderAL, $_days*/
      6 && span_aria_label_value !== (span_aria_label_value = /*$_intlDayHeaderAL*/
      ctx[2].format(
        /*day*/
        ctx[8]
      ))) {
        attr(span, "aria-label", span_aria_label_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_days*/
      10) setContent_action.update.call(
        null,
        /*$_intlDayHeader*/
        ctx[3].format(
          /*day*/
          ctx[8]
        )
      );
      if (dirty & /*$theme, $_days*/
      3 && div_class_value !== (div_class_value = /*$theme*/
      ctx[0].day + " " + /*$theme*/
      ((_a2 = ctx[0].weekdays) == null ? void 0 : _a2[
        /*day*/
        ctx[8].getUTCDay()
      ]))) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$6(ctx) {
  let div2;
  let div0;
  let div0_class_value;
  let t;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let each_value = ensure_array_like(
    /*$_days*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div1 = element("div");
      attr(div0, "class", div0_class_value = /*$theme*/
      ctx[0].days);
      attr(div0, "role", "row");
      attr(div1, "class", div1_class_value = /*$theme*/
      ctx[0].hiddenScroll);
      attr(div2, "class", div2_class_value = /*$theme*/
      ctx[0].header);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t);
      append(div2, div1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader*/
      15) {
        each_value = ensure_array_like(
          /*$_days*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$theme*/
      1 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[0].days)) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$theme*/
      1 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[0].hiddenScroll)) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$theme*/
      1 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx2[0].header)) {
        attr(div2, "class", div2_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $theme;
  let $_days;
  let $_intlDayHeaderAL;
  let $_intlDayHeader;
  let { theme, _intlDayHeader, _intlDayHeaderAL, _days } = getContext("state");
  component_subscribe($$self, theme, (value) => $$invalidate(0, $theme = value));
  component_subscribe($$self, _intlDayHeader, (value) => $$invalidate(3, $_intlDayHeader = value));
  component_subscribe($$self, _intlDayHeaderAL, (value) => $$invalidate(2, $_intlDayHeaderAL = value));
  component_subscribe($$self, _days, (value) => $$invalidate(1, $_days = value));
  return [
    $theme,
    $_days,
    $_intlDayHeaderAL,
    $_intlDayHeader,
    theme,
    _intlDayHeader,
    _intlDayHeaderAL,
    _days
  ];
}
var Header = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
  }
};
function create_fragment$5(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      attr(div0, "class", div0_class_value = /*$theme*/
      ctx[0].content);
      attr(div1, "class", div1_class_value = /*$theme*/
      ctx[0].body + /*$dayMaxEvents*/
      (ctx[1] === true ? " " + /*$theme*/
      ctx[0].uniform : ""));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[8](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$theme*/
      1 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[0].content)) {
        attr(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*$theme, $dayMaxEvents*/
      3 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[0].body + /*$dayMaxEvents*/
      (ctx2[1] === true ? " " + /*$theme*/
      ctx2[0].uniform : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[8](null);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $theme;
  let $dayMaxEvents;
  let $_bodyEl;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { dayMaxEvents, _bodyEl, theme } = getContext("state");
  component_subscribe($$self, dayMaxEvents, (value) => $$invalidate(1, $dayMaxEvents = value));
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(2, $_bodyEl = value));
  component_subscribe($$self, theme, (value) => $$invalidate(0, $theme = value));
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $_bodyEl = $$value;
      _bodyEl.set($_bodyEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    $theme,
    $dayMaxEvents,
    $_bodyEl,
    dayMaxEvents,
    _bodyEl,
    theme,
    $$scope,
    slots,
    div1_binding
  ];
}
var Body = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
  }
};
function create_fragment$4(ctx) {
  let article;
  let div;
  let div_class_value;
  let setContent_action;
  let t;
  let switch_instance;
  let article_role_value;
  let article_tabindex_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*$_interaction*/
    ctx[8].resizer
  );
  function switch_props(ctx2, dirty) {
    return { props: { event: (
      /*event*/
      ctx2[0]
    ) } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance.$on("pointerdown", function() {
      if (is_function(
        /*createDragHandler*/
        ctx[33](
          /*$_interaction*/
          ctx[8],
          true
        )
      )) ctx[33](
        /*$_interaction*/
        ctx[8],
        true
      ).apply(this, arguments);
    });
  }
  return {
    c() {
      article = element("article");
      div = element("div");
      t = space();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      attr(div, "class", div_class_value = /*$theme*/
      ctx[2].eventBody);
      attr(
        article,
        "class",
        /*classes*/
        ctx[4]
      );
      attr(
        article,
        "style",
        /*style*/
        ctx[5]
      );
      attr(article, "role", article_role_value = /*onclick*/
      ctx[7] ? "button" : void 0);
      attr(article, "tabindex", article_tabindex_value = /*onclick*/
      ctx[7] ? 0 : void 0);
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t);
      if (switch_instance) mount_component(switch_instance, article, null);
      ctx[52](article);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            div,
            /*content*/
            ctx[6]
          )),
          listen(article, "click", function() {
            if (is_function(
              /*onclick*/
              ctx[7] || void 0
            )) /*onclick*/
            (ctx[7] || void 0).apply(this, arguments);
          }),
          listen(article, "keydown", function() {
            if (is_function(
              /*onclick*/
              ctx[7] && keyEnter(
                /*onclick*/
                ctx[7]
              )
            )) /*onclick*/
            (ctx[7] && keyEnter(
              /*onclick*/
              ctx[7]
            )).apply(this, arguments);
          }),
          listen(article, "mouseenter", function() {
            if (is_function(
              /*createHandler*/
              ctx[32](
                /*$eventMouseEnter*/
                ctx[9],
                /*display*/
                ctx[1]
              )
            )) ctx[32](
              /*$eventMouseEnter*/
              ctx[9],
              /*display*/
              ctx[1]
            ).apply(this, arguments);
          }),
          listen(article, "mouseleave", function() {
            if (is_function(
              /*createHandler*/
              ctx[32](
                /*$eventMouseLeave*/
                ctx[10],
                /*display*/
                ctx[1]
              )
            )) ctx[32](
              /*$eventMouseLeave*/
              ctx[10],
              /*display*/
              ctx[1]
            ).apply(this, arguments);
          }),
          listen(article, "pointerdown", function() {
            if (is_function(!helperEvent(
              /*display*/
              ctx[1]
            ) && /*createDragHandler*/
            ctx[33](
              /*$_interaction*/
              ctx[8]
            ))) (!helperEvent(
              /*display*/
              ctx[1]
            ) && /*createDragHandler*/
            ctx[33](
              /*$_interaction*/
              ctx[8]
            )).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      4 && div_class_value !== (div_class_value = /*$theme*/
      ctx[2].eventBody)) {
        attr(div, "class", div_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/
      64) setContent_action.update.call(
        null,
        /*content*/
        ctx[6]
      );
      if (dirty[0] & /*$_interaction*/
      256 && switch_value !== (switch_value = /*$_interaction*/
      ctx[8].resizer)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          switch_instance.$on("pointerdown", function() {
            if (is_function(
              /*createDragHandler*/
              ctx[33](
                /*$_interaction*/
                ctx[8],
                true
              )
            )) ctx[33](
              /*$_interaction*/
              ctx[8],
              true
            ).apply(this, arguments);
          });
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, article, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*event*/
        1) switch_instance_changes.event = /*event*/
        ctx[0];
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*classes*/
      16) {
        attr(
          article,
          "class",
          /*classes*/
          ctx[4]
        );
      }
      if (!current || dirty[0] & /*style*/
      32) {
        attr(
          article,
          "style",
          /*style*/
          ctx[5]
        );
      }
      if (!current || dirty[0] & /*onclick*/
      128 && article_role_value !== (article_role_value = /*onclick*/
      ctx[7] ? "button" : void 0)) {
        attr(article, "role", article_role_value);
      }
      if (!current || dirty[0] & /*onclick*/
      128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/
      ctx[7] ? 0 : void 0)) {
        attr(article, "tabindex", article_tabindex_value);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[52](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $eventClick;
  let $_hiddenEvents;
  let $dayMaxEvents;
  let $_popupDate;
  let $_interaction;
  let $_view;
  let $eventAllUpdated;
  let $eventDidMount;
  let $_intlEventTime;
  let $theme;
  let $eventContent;
  let $displayEventEnd;
  let $eventClassNames;
  let $_iClasses;
  let $eventTextColor;
  let $_resTxtColor;
  let $eventColor;
  let $eventBackgroundColor;
  let $_resBgColor;
  let $eventMouseEnter;
  let $eventMouseLeave;
  let { chunk } = $$props;
  let { longChunks = {} } = $$props;
  let { inPopup = false } = $$props;
  let { dayMaxEvents, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _hiddenEvents, _popupDate, _tasks } = getContext("state");
  component_subscribe($$self, dayMaxEvents, (value) => $$invalidate(55, $dayMaxEvents = value));
  component_subscribe($$self, displayEventEnd, (value) => $$invalidate(44, $displayEventEnd = value));
  component_subscribe($$self, eventAllUpdated, (value) => $$invalidate(57, $eventAllUpdated = value));
  component_subscribe($$self, eventBackgroundColor, (value) => $$invalidate(50, $eventBackgroundColor = value));
  component_subscribe($$self, eventTextColor, (value) => $$invalidate(47, $eventTextColor = value));
  component_subscribe($$self, eventClick, (value) => $$invalidate(40, $eventClick = value));
  component_subscribe($$self, eventColor, (value) => $$invalidate(49, $eventColor = value));
  component_subscribe($$self, eventContent, (value) => $$invalidate(43, $eventContent = value));
  component_subscribe($$self, eventClassNames, (value) => $$invalidate(45, $eventClassNames = value));
  component_subscribe($$self, eventDidMount, (value) => $$invalidate(58, $eventDidMount = value));
  component_subscribe($$self, eventMouseEnter, (value) => $$invalidate(9, $eventMouseEnter = value));
  component_subscribe($$self, eventMouseLeave, (value) => $$invalidate(10, $eventMouseLeave = value));
  component_subscribe($$self, theme, (value) => $$invalidate(2, $theme = value));
  component_subscribe($$self, _view, (value) => $$invalidate(41, $_view = value));
  component_subscribe($$self, _intlEventTime, (value) => $$invalidate(42, $_intlEventTime = value));
  component_subscribe($$self, _interaction, (value) => $$invalidate(8, $_interaction = value));
  component_subscribe($$self, _iClasses, (value) => $$invalidate(46, $_iClasses = value));
  component_subscribe($$self, _resBgColor, (value) => $$invalidate(51, $_resBgColor = value));
  component_subscribe($$self, _resTxtColor, (value) => $$invalidate(48, $_resTxtColor = value));
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(54, $_hiddenEvents = value));
  component_subscribe($$self, _popupDate, (value) => $$invalidate(56, $_popupDate = value));
  let el;
  let event;
  let classes;
  let style;
  let content;
  let timeText;
  let margin = 1;
  let hidden = false;
  let display;
  let onclick;
  onMount(() => {
    if (is_function($eventDidMount)) {
      $eventDidMount({
        event: toEventWithLocalDates(event),
        timeText,
        el,
        view: toViewWithLocalDates($_view)
      });
    }
  });
  afterUpdate(() => {
    if (is_function($eventAllUpdated) && !helperEvent(display)) {
      task(() => $eventAllUpdated({ view: toViewWithLocalDates($_view) }), "eau", _tasks);
    }
  });
  function createHandler(fn, display2) {
    return !helperEvent(display2) && is_function(fn) ? (jsEvent) => fn({
      event: toEventWithLocalDates(event),
      el,
      jsEvent,
      view: toViewWithLocalDates($_view)
    }) : void 0;
  }
  function createDragHandler(interaction, resize) {
    return interaction.action ? (jsEvent) => $_interaction.action.drag(event, jsEvent, resize, inPopup ? $_popupDate : void 0) : void 0;
  }
  function reposition() {
    if (!el) {
      return;
    }
    $$invalidate(38, margin = repositionEvent(chunk, longChunks, height(el)));
    if ($dayMaxEvents === true) {
      hide();
    } else {
      $$invalidate(39, hidden = false);
    }
  }
  function hide() {
    let dayEl = ancestor(el, 2);
    let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
    $$invalidate(39, hidden = chunk.bottom > h);
    let update2 = false;
    for (let date of chunk.dates) {
      let hiddenEvents = $_hiddenEvents[date.getTime()];
      if (hiddenEvents) {
        let size = hiddenEvents.size;
        if (hidden) {
          hiddenEvents.add(chunk.event);
        } else {
          hiddenEvents.delete(chunk.event);
        }
        if (size !== hiddenEvents.size) {
          update2 = true;
        }
      }
    }
    if (update2) {
      _hiddenEvents.set($_hiddenEvents);
    }
  }
  function footHeight(dayEl) {
    let h = 0;
    for (let i = 0; i < chunk.days; ++i) {
      h = max(h, height(dayEl.lastElementChild));
      dayEl = dayEl.nextElementSibling;
      if (!dayEl) {
        break;
      }
    }
    return h;
  }
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("chunk" in $$props2) $$invalidate(34, chunk = $$props2.chunk);
    if ("longChunks" in $$props2) $$invalidate(35, longChunks = $$props2.longChunks);
    if ("inPopup" in $$props2) $$invalidate(36, inPopup = $$props2.inPopup);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*chunk*/
    8) {
      $$invalidate(0, event = chunk.event);
    }
    if ($$self.$$.dirty[0] & /*event, style, $theme*/
    37 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, chunk, margin, hidden, $_iClasses, $eventClassNames, $_view*/
    2082184) {
      {
        $$invalidate(1, display = event.display);
        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);margin-top:${margin}px;`);
        if (bgColor) {
          $$invalidate(5, style += `background-color:${bgColor};`);
        }
        if (txtColor) {
          $$invalidate(5, style += `color:${txtColor};`);
        }
        if (hidden) {
          $$invalidate(5, style += "visibility:hidden;");
        }
        $$invalidate(4, classes = [
          $theme.event,
          ...$_iClasses([], event),
          ...createEventClasses($eventClassNames, event, $_view)
        ].join(" "));
      }
    }
    if ($$self.$$.dirty[0] & /*$theme*/
    4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/
    15368) {
      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
    }
    if ($$self.$$.dirty[0] & /*display*/
    2 | $$self.$$.dirty[1] & /*$eventClick*/
    512) {
      $$invalidate(7, onclick = createHandler($eventClick, display));
    }
  };
  return [
    event,
    display,
    $theme,
    el,
    classes,
    style,
    content,
    onclick,
    $_interaction,
    $eventMouseEnter,
    $eventMouseLeave,
    dayMaxEvents,
    displayEventEnd,
    eventAllUpdated,
    eventBackgroundColor,
    eventTextColor,
    eventClick,
    eventColor,
    eventContent,
    eventClassNames,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _iClasses,
    _resBgColor,
    _resTxtColor,
    _hiddenEvents,
    _popupDate,
    createHandler,
    createDragHandler,
    chunk,
    longChunks,
    inPopup,
    reposition,
    margin,
    hidden,
    $eventClick,
    $_view,
    $_intlEventTime,
    $eventContent,
    $displayEventEnd,
    $eventClassNames,
    $_iClasses,
    $eventTextColor,
    $_resTxtColor,
    $eventColor,
    $eventBackgroundColor,
    $_resBgColor,
    article_binding
  ];
}
var Event = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$4,
      create_fragment$4,
      safe_not_equal,
      {
        chunk: 34,
        longChunks: 35,
        inPopup: 36,
        reposition: 37
      },
      null,
      [-1, -1]
    );
  }
  get reposition() {
    return this.$$.ctx[37];
  }
};
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_each_block$3(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event({
    props: { chunk: (
      /*chunk*/
      ctx[20]
    ), inPopup: true }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(event.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty & /*$_popupChunks*/
      1) event_changes.chunk = /*chunk*/
      ctx[20];
      event.$set(event_changes);
    },
    i(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(event, detaching);
    }
  };
}
function create_fragment$32(ctx) {
  let div2;
  let div0;
  let time;
  let time_datetime_value;
  let setContent_action;
  let t0;
  let a;
  let t1;
  let a_aria_label_value;
  let div0_class_value;
  let t2;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$_popupChunks*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[20].event
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      time = element("time");
      t0 = space();
      a = element("a");
      t1 = text("\xD7");
      t2 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(time, "datetime", time_datetime_value = toISOString(
        /*$_popupDate*/
        ctx[3],
        10
      ));
      attr(a, "role", "button");
      attr(a, "tabindex", "0");
      attr(a, "aria-label", a_aria_label_value = /*$buttonText*/
      ctx[6].close);
      attr(div0, "class", div0_class_value = /*$theme*/
      ctx[4].dayHead);
      attr(div1, "class", div1_class_value = /*$theme*/
      ctx[4].events);
      attr(div2, "class", div2_class_value = /*$theme*/
      ctx[4].popup);
      attr(
        div2,
        "style",
        /*style*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, time);
      append(div0, t0);
      append(div0, a);
      append(a, t1);
      append(div2, t2);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      ctx[16](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            time,
            /*$_intlDayPopover*/
            ctx[5].format(
              /*$_popupDate*/
              ctx[3]
            )
          )),
          listen(a, "click", stop_propagation(
            /*close*/
            ctx[13]
          )),
          listen(a, "keydown", keyEnter(
            /*close*/
            ctx[13]
          )),
          action_destroyer(outsideEvent.call(null, div2, "pointerdown")),
          listen(div2, "pointerdown", stop_propagation(
            /*pointerdown_handler*/
            ctx[15]
          )),
          listen(
            div2,
            "pointerdownoutside",
            /*handlePointerDownOutside*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$_popupDate*/
      8 && time_datetime_value !== (time_datetime_value = toISOString(
        /*$_popupDate*/
        ctx2[3],
        10
      ))) {
        attr(time, "datetime", time_datetime_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayPopover, $_popupDate*/
      40) setContent_action.update.call(
        null,
        /*$_intlDayPopover*/
        ctx2[5].format(
          /*$_popupDate*/
          ctx2[3]
        )
      );
      if (!current || dirty & /*$buttonText*/
      64 && a_aria_label_value !== (a_aria_label_value = /*$buttonText*/
      ctx2[6].close)) {
        attr(a, "aria-label", a_aria_label_value);
      }
      if (!current || dirty & /*$theme*/
      16 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[4].dayHead)) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$_popupChunks*/
      1) {
        each_value = ensure_array_like(
          /*$_popupChunks*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      16 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[4].events)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$theme*/
      16 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx2[4].popup)) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*style*/
      4) {
        attr(
          div2,
          "style",
          /*style*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let $_interaction;
  let $_popupDate;
  let $_popupChunks;
  let $theme;
  let $_intlDayPopover;
  let $buttonText;
  let { buttonText, theme, _interaction, _intlDayPopover, _popupDate, _popupChunks } = getContext("state");
  component_subscribe($$self, buttonText, (value) => $$invalidate(6, $buttonText = value));
  component_subscribe($$self, theme, (value) => $$invalidate(4, $theme = value));
  component_subscribe($$self, _interaction, (value) => $$invalidate(17, $_interaction = value));
  component_subscribe($$self, _intlDayPopover, (value) => $$invalidate(5, $_intlDayPopover = value));
  component_subscribe($$self, _popupDate, (value) => $$invalidate(3, $_popupDate = value));
  component_subscribe($$self, _popupChunks, (value) => $$invalidate(0, $_popupChunks = value));
  let el;
  let style = "";
  function position() {
    let dayEl = ancestor(el, 1);
    let bodyEl = ancestor(dayEl, 3);
    let popupRect = rect(el);
    let dayRect = rect(dayEl);
    let bodyRect = rect(bodyEl);
    $$invalidate(2, style = "");
    let left;
    if (popupRect.width >= bodyRect.width) {
      left = bodyRect.left - dayRect.left;
      let right = dayRect.right - bodyRect.right;
      $$invalidate(2, style += `right:${right}px;`);
    } else {
      left = (dayRect.width - popupRect.width) / 2;
      if (dayRect.left + left < bodyRect.left) {
        left = bodyRect.left - dayRect.left;
      } else if (dayRect.left + left + popupRect.width > bodyRect.right) {
        left = bodyRect.right - dayRect.left - popupRect.width;
      }
    }
    $$invalidate(2, style += `left:${left}px;`);
    let top;
    if (popupRect.height >= bodyRect.height) {
      top = bodyRect.top - dayRect.top;
      let bottom = dayRect.bottom - bodyRect.bottom;
      $$invalidate(2, style += `bottom:${bottom}px;`);
    } else {
      top = (dayRect.height - popupRect.height) / 2;
      if (dayRect.top + top < bodyRect.top) {
        top = bodyRect.top - dayRect.top;
      } else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
        top = bodyRect.bottom - dayRect.top - popupRect.height;
      }
    }
    $$invalidate(2, style += `top:${top}px;`);
  }
  function reposition() {
    if (el) {
      $$invalidate(2, style = "");
      tick().then(() => {
        if ($_popupChunks.length) {
          position();
        } else {
          close();
        }
      });
    }
  }
  function close(e) {
    set_store_value(_popupDate, $_popupDate = null, $_popupDate);
  }
  function handlePointerDownOutside(e) {
    var _a2;
    close();
    (_a2 = $_interaction.action) == null ? void 0 : _a2.noClick();
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_popupChunks*/
    1) {
      if ($_popupChunks) {
        reposition();
      }
    }
  };
  return [
    $_popupChunks,
    el,
    style,
    $_popupDate,
    $theme,
    $_intlDayPopover,
    $buttonText,
    buttonText,
    theme,
    _interaction,
    _intlDayPopover,
    _popupDate,
    _popupChunks,
    close,
    handlePointerDownOutside,
    pointerdown_handler,
    div2_binding
  ];
}
var Popup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$32, create_fragment$32, safe_not_equal, {});
  }
};
function get_each_context$22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  child_ctx[43] = list;
  child_ctx[44] = i;
  return child_ctx;
}
function create_if_block_32(ctx) {
  let div;
  let event;
  let div_class_value;
  let current;
  event = new Event({ props: { chunk: (
    /*iChunks*/
    ctx[2][1]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(event.$$.fragment);
      attr(div, "class", div_class_value = /*$theme*/
      ctx[12].events);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(event, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*iChunks*/
      4) event_changes.chunk = /*iChunks*/
      ctx2[2][1];
      event.$set(event_changes);
      if (!current || dirty[0] & /*$theme*/
      4096 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[12].events)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(event);
    }
  };
}
function create_if_block_22(ctx) {
  let div;
  let event;
  let div_class_value;
  let current;
  event = new Event({ props: { chunk: (
    /*iChunks*/
    ctx[2][0]
  ) } });
  return {
    c() {
      div = element("div");
      create_component(event.$$.fragment);
      attr(div, "class", div_class_value = /*$theme*/
      ctx[12].events + " " + /*$theme*/
      ctx[12].preview);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(event, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*iChunks*/
      4) event_changes.chunk = /*iChunks*/
      ctx2[2][0];
      event.$set(event_changes);
      if (!current || dirty[0] & /*$theme*/
      4096 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[12].events + " " + /*$theme*/
      ctx2[12].preview)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(event);
    }
  };
}
function create_each_block$22(key_1, ctx) {
  let first;
  let event;
  let i = (
    /*i*/
    ctx[44]
  );
  let current;
  const assign_event = () => (
    /*event_binding*/
    ctx[36](event, i)
  );
  const unassign_event = () => (
    /*event_binding*/
    ctx[36](null, i)
  );
  let event_props = {
    chunk: (
      /*chunk*/
      ctx[42]
    ),
    longChunks: (
      /*longChunks*/
      ctx[1]
    )
  };
  event = new Event({ props: event_props });
  assign_event();
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(event.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (i !== /*i*/
      ctx[44]) {
        unassign_event();
        i = /*i*/
        ctx[44];
        assign_event();
      }
      const event_changes = {};
      if (dirty[0] & /*dayChunks*/
      16) event_changes.chunk = /*chunk*/
      ctx[42];
      if (dirty[0] & /*longChunks*/
      2) event_changes.longChunks = /*longChunks*/
      ctx[1];
      event.$set(event_changes);
    },
    i(local) {
      if (current) return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      unassign_event();
      destroy_component(event, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let popup;
  let current;
  popup = new Popup({});
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let a;
  let setContent_action;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      attr(a, "role", "button");
      attr(a, "tabindex", "0");
      attr(a, "aria-haspopup", "true");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = [
          listen(a, "click", stop_propagation(
            /*showMore*/
            ctx[26]
          )),
          listen(a, "keydown", keyEnter(
            /*showMore*/
            ctx[26]
          )),
          listen(a, "pointerdown", stop_propagation(
            /*pointerdown_handler*/
            ctx[35]
          )),
          action_destroyer(setContent_action = setContent.call(
            null,
            a,
            /*moreLink*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/
      1024) setContent_action.update.call(
        null,
        /*moreLink*/
        ctx2[10]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$22(ctx) {
  let div2;
  let time;
  let time_class_value;
  let time_datetime_value;
  let setContent_action;
  let t0;
  let show_if_1 = (
    /*iChunks*/
    ctx[2][1] && datesEqual(
      /*iChunks*/
      ctx[2][1].date,
      /*date*/
      ctx[0]
    )
  );
  let t1;
  let show_if = (
    /*iChunks*/
    ctx[2][0] && datesEqual(
      /*iChunks*/
      ctx[2][0].date,
      /*date*/
      ctx[0]
    )
  );
  let t2;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let t3;
  let t4;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if_1 && create_if_block_32(ctx);
  let if_block1 = show_if && create_if_block_22(ctx);
  let each_value = ensure_array_like(
    /*dayChunks*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[42].event
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$22(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$22(key, child_ctx));
  }
  let if_block2 = (
    /*showPopup*/
    ctx[6] && create_if_block_12()
  );
  let if_block3 = (
    /*hiddenEvents*/
    ctx[5].size && create_if_block2(ctx)
  );
  return {
    c() {
      var _a2;
      div2 = element("div");
      time = element("time");
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      div1 = element("div");
      if (if_block3) if_block3.c();
      attr(time, "class", time_class_value = /*$theme*/
      ctx[12].dayHead);
      attr(time, "datetime", time_datetime_value = toISOString(
        /*date*/
        ctx[0],
        10
      ));
      attr(div0, "class", div0_class_value = /*$theme*/
      ctx[12].events);
      attr(div1, "class", div1_class_value = /*$theme*/
      ctx[12].dayFoot);
      attr(div2, "class", div2_class_value = /*$theme*/
      ctx[12].day + " " + /*$theme*/
      ((_a2 = ctx[12].weekdays) == null ? void 0 : _a2[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[7] ? " " + /*$theme*/
      ctx[12].today : "") + /*otherMonth*/
      (ctx[8] ? " " + /*$theme*/
      ctx[12].otherMonth : "") + /*highlight*/
      (ctx[9] ? " " + /*$theme*/
      ctx[12].highlight : ""));
      attr(div2, "role", "cell");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, time);
      append(div2, t0);
      if (if_block0) if_block0.m(div2, null);
      append(div2, t1);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t2);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t3);
      if (if_block2) if_block2.m(div2, null);
      append(div2, t4);
      append(div2, div1);
      if (if_block3) if_block3.m(div1, null);
      ctx[37](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            time,
            /*$_intlDayCell*/
            ctx[14].format(
              /*date*/
              ctx[0]
            )
          )),
          listen(div2, "pointerenter", function() {
            if (is_function(
              /*createPointerEnterHandler*/
              ctx[25](
                /*$_interaction*/
                ctx[13]
              )
            )) ctx[25](
              /*$_interaction*/
              ctx[13]
            ).apply(this, arguments);
          }),
          listen(div2, "pointerleave", function() {
            var _a2, _b;
            if (is_function(
              /*$_interaction*/
              (_a2 = ctx[13].pointer) == null ? void 0 : _a2.leave
            )) (_b = ctx[13].pointer) == null ? void 0 : _b.leave.apply(this, arguments);
          }),
          listen(div2, "pointerdown", function() {
            var _a2, _b;
            if (is_function(
              /*$_interaction*/
              (_a2 = ctx[13].action) == null ? void 0 : _a2.select
            )) (_b = ctx[13].action) == null ? void 0 : _b.select.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      4096 && time_class_value !== (time_class_value = /*$theme*/
      ctx[12].dayHead)) {
        attr(time, "class", time_class_value);
      }
      if (!current || dirty[0] & /*date*/
      1 && time_datetime_value !== (time_datetime_value = toISOString(
        /*date*/
        ctx[0],
        10
      ))) {
        attr(time, "datetime", time_datetime_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayCell, date*/
      16385) setContent_action.update.call(
        null,
        /*$_intlDayCell*/
        ctx[14].format(
          /*date*/
          ctx[0]
        )
      );
      if (dirty[0] & /*iChunks, date*/
      5) show_if_1 = /*iChunks*/
      ctx[2][1] && datesEqual(
        /*iChunks*/
        ctx[2][1].date,
        /*date*/
        ctx[0]
      );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*iChunks, date*/
          5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*iChunks, date*/
      5) show_if = /*iChunks*/
      ctx[2][0] && datesEqual(
        /*iChunks*/
        ctx[2][0].date,
        /*date*/
        ctx[0]
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*iChunks, date*/
          5) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*dayChunks, longChunks, refs*/
      2066) {
        each_value = ensure_array_like(
          /*dayChunks*/
          ctx[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$22, null, get_each_context$22);
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      4096 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[12].events)) {
        attr(div0, "class", div0_class_value);
      }
      if (
        /*showPopup*/
        ctx[6]
      ) {
        if (if_block2) {
          if (dirty[0] & /*showPopup*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_12();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*hiddenEvents*/
        ctx[5].size
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if_block3 = create_if_block2(ctx);
          if_block3.c();
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty[0] & /*$theme*/
      4096 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[12].dayFoot)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*$theme, date, isToday, otherMonth, highlight*/
      4993 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx[12].day + " " + /*$theme*/
      ((_a2 = ctx[12].weekdays) == null ? void 0 : _a2[
        /*date*/
        ctx[0].getUTCDay()
      ]) + /*isToday*/
      (ctx[7] ? " " + /*$theme*/
      ctx[12].today : "") + /*otherMonth*/
      (ctx[8] ? " " + /*$theme*/
      ctx[12].otherMonth : "") + /*highlight*/
      (ctx[9] ? " " + /*$theme*/
      ctx[12].highlight : ""))) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$22($$self, $$props, $$invalidate) {
  let $_popupChunks;
  let $_popupDate;
  let $moreLinkContent;
  let $_hiddenEvents;
  let $highlightedDates;
  let $currentDate;
  let $_today;
  let $theme;
  let $_interaction;
  let $_intlDayCell;
  let { date } = $$props;
  let { chunks } = $$props;
  let { longChunks } = $$props;
  let { iChunks = [] } = $$props;
  let { date: currentDate, dayMaxEvents, highlightedDates, moreLinkContent, theme, _hiddenEvents, _intlDayCell, _popupDate, _popupChunks, _today, _interaction, _queue } = getContext("state");
  component_subscribe($$self, currentDate, (value) => $$invalidate(33, $currentDate = value));
  component_subscribe($$self, highlightedDates, (value) => $$invalidate(32, $highlightedDates = value));
  component_subscribe($$self, moreLinkContent, (value) => $$invalidate(30, $moreLinkContent = value));
  component_subscribe($$self, theme, (value) => $$invalidate(12, $theme = value));
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(31, $_hiddenEvents = value));
  component_subscribe($$self, _intlDayCell, (value) => $$invalidate(14, $_intlDayCell = value));
  component_subscribe($$self, _popupDate, (value) => $$invalidate(29, $_popupDate = value));
  component_subscribe($$self, _popupChunks, (value) => $$invalidate(38, $_popupChunks = value));
  component_subscribe($$self, _today, (value) => $$invalidate(34, $_today = value));
  component_subscribe($$self, _interaction, (value) => $$invalidate(13, $_interaction = value));
  let el;
  let dayChunks;
  let isToday;
  let otherMonth;
  let highlight;
  let hiddenEvents = /* @__PURE__ */ new Set();
  let moreLink = "";
  let showPopup;
  let refs = [];
  function createPointerEnterHandler(interaction) {
    return interaction.pointer ? (jsEvent) => interaction.pointer.enterDayGrid(date, jsEvent) : void 0;
  }
  function showMore() {
    set_store_value(_popupDate, $_popupDate = date, $_popupDate);
  }
  function setPopupChunks() {
    var _a2;
    let nextDay = addDay(cloneDate(date));
    let chunks2 = dayChunks.concat(((_a2 = longChunks[date.getTime()]) == null ? void 0 : _a2.chunks) || []);
    set_store_value(_popupChunks, $_popupChunks = chunks2.map((chunk) => assign2({}, chunk, createEventChunk(chunk.event, date, nextDay), { days: 1, dates: [date] })).sort((a, b) => a.top - b.top), $_popupChunks);
  }
  function reposition() {
    runReposition(refs, dayChunks);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function event_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refs[i] = $$value;
      $$invalidate(11, refs);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2) $$invalidate(0, date = $$props2.date);
    if ("chunks" in $$props2) $$invalidate(27, chunks = $$props2.chunks);
    if ("longChunks" in $$props2) $$invalidate(1, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2) $$invalidate(2, iChunks = $$props2.iChunks);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*hiddenEvents, chunks, date, dayChunks*/
    134217777) {
      {
        $$invalidate(4, dayChunks = []);
        hiddenEvents.clear();
        $$invalidate(5, hiddenEvents), $$invalidate(27, chunks), $$invalidate(0, date), $$invalidate(4, dayChunks);
        for (let chunk of chunks) {
          if (datesEqual(chunk.date, date)) {
            dayChunks.push(chunk);
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*date, hiddenEvents*/
    33) {
      set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$_today*/
    8) {
      $$invalidate(7, isToday = datesEqual(date, $_today));
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/
    6) {
      {
        $$invalidate(8, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
        $$invalidate(9, highlight = $highlightedDates.some((d) => datesEqual(d, date)));
      }
    }
    if ($$self.$$.dirty[0] & /*hiddenEvents, $moreLinkContent*/
    1073741856 | $$self.$$.dirty[1] & /*$_hiddenEvents*/
    1) {
      if ($_hiddenEvents && hiddenEvents.size) {
        let text2 = "+" + hiddenEvents.size + " more";
        if ($moreLinkContent) {
          $$invalidate(10, moreLink = is_function($moreLinkContent) ? $moreLinkContent({ num: hiddenEvents.size, text: text2 }) : $moreLinkContent);
        } else {
          $$invalidate(10, moreLink = text2);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*$_popupDate, date*/
    536870913) {
      $$invalidate(6, showPopup = $_popupDate && datesEqual(date, $_popupDate));
    }
    if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/
    82) {
      if (showPopup && longChunks && dayChunks) {
        tick().then(setPopupChunks);
      }
    }
    if ($$self.$$.dirty[0] & /*el, date*/
    9) {
      if (el) {
        setPayload(el, () => ({
          allDay: true,
          date,
          resource: void 0,
          dayEl: el
        }));
      }
    }
  };
  return [
    date,
    longChunks,
    iChunks,
    el,
    dayChunks,
    hiddenEvents,
    showPopup,
    isToday,
    otherMonth,
    highlight,
    moreLink,
    refs,
    $theme,
    $_interaction,
    $_intlDayCell,
    currentDate,
    highlightedDates,
    moreLinkContent,
    theme,
    _hiddenEvents,
    _intlDayCell,
    _popupDate,
    _popupChunks,
    _today,
    _interaction,
    createPointerEnterHandler,
    showMore,
    chunks,
    reposition,
    $_popupDate,
    $moreLinkContent,
    $_hiddenEvents,
    $highlightedDates,
    $currentDate,
    $_today,
    pointerdown_handler,
    event_binding,
    div2_binding
  ];
}
var Day = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$22,
      create_fragment$22,
      safe_not_equal,
      {
        date: 0,
        chunks: 27,
        longChunks: 1,
        iChunks: 2,
        reposition: 28
      },
      null,
      [-1, -1]
    );
  }
  get reposition() {
    return this.$$.ctx[28];
  }
};
function get_each_context$12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  child_ctx[22] = list;
  child_ctx[23] = i;
  return child_ctx;
}
function create_each_block$12(ctx) {
  let day;
  let i = (
    /*i*/
    ctx[23]
  );
  let current;
  const assign_day = () => (
    /*day_binding*/
    ctx[18](day, i)
  );
  const unassign_day = () => (
    /*day_binding*/
    ctx[18](null, i)
  );
  let day_props = {
    date: (
      /*date*/
      ctx[21]
    ),
    chunks: (
      /*chunks*/
      ctx[1]
    ),
    longChunks: (
      /*longChunks*/
      ctx[2]
    ),
    iChunks: (
      /*iChunks*/
      ctx[3]
    )
  };
  day = new Day({ props: day_props });
  assign_day();
  return {
    c() {
      create_component(day.$$.fragment);
    },
    m(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (i !== /*i*/
      ctx2[23]) {
        unassign_day();
        i = /*i*/
        ctx2[23];
        assign_day();
      }
      const day_changes = {};
      if (dirty & /*dates*/
      1) day_changes.date = /*date*/
      ctx2[21];
      if (dirty & /*chunks*/
      2) day_changes.chunks = /*chunks*/
      ctx2[1];
      if (dirty & /*longChunks*/
      4) day_changes.longChunks = /*longChunks*/
      ctx2[2];
      if (dirty & /*iChunks*/
      8) day_changes.iChunks = /*iChunks*/
      ctx2[3];
      day.$set(day_changes);
    },
    i(local) {
      if (current) return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      unassign_day();
      destroy_component(day, detaching);
    }
  };
}
function create_fragment$12(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*dates*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$12(get_each_context$12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = /*$theme*/
      ctx[5].days);
      attr(div, "role", "row");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "resize",
          /*reposition*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*dates, chunks, longChunks, iChunks, refs*/
      31) {
        each_value = ensure_array_like(
          /*dates*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      32 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[5].days)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let $_hiddenEvents;
  let $hiddenDays;
  let $_iEvents;
  let $_events;
  let $theme;
  let { dates } = $$props;
  let { _events, _iEvents, _queue2, _hiddenEvents, hiddenDays, theme } = getContext("state");
  component_subscribe($$self, _events, (value) => $$invalidate(17, $_events = value));
  component_subscribe($$self, _iEvents, (value) => $$invalidate(16, $_iEvents = value));
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(14, $_hiddenEvents = value));
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(15, $hiddenDays = value));
  component_subscribe($$self, theme, (value) => $$invalidate(5, $theme = value));
  let chunks, longChunks, iChunks = [];
  let start;
  let end;
  let refs = [];
  let debounceHandle = {};
  function reposition() {
    debounce(() => runReposition(refs, dates), debounceHandle, _queue2);
  }
  function day_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refs[i] = $$value;
      $$invalidate(4, refs);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("dates" in $$props2) $$invalidate(0, dates = $$props2.dates);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dates*/
    1) {
      {
        $$invalidate(12, start = dates[0]);
        $$invalidate(13, end = addDay(cloneDate(dates[dates.length - 1])));
      }
    }
    if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/
    176130) {
      {
        $$invalidate(1, chunks = []);
        for (let event of $_events) {
          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
            let chunk = createEventChunk(event, start, end);
            chunks.push(chunk);
          }
        }
        $$invalidate(2, longChunks = prepareEventChunks(chunks, $hiddenDays));
        reposition();
      }
    }
    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/
    110592) {
      $$invalidate(3, iChunks = $_iEvents.map((event) => {
        let chunk;
        if (event && eventIntersects(event, start, end)) {
          chunk = createEventChunk(event, start, end);
          prepareEventChunks([chunk], $hiddenDays);
        } else {
          chunk = null;
        }
        return chunk;
      }));
    }
    if ($$self.$$.dirty & /*$_hiddenEvents*/
    16384) {
      if ($_hiddenEvents) {
        tick().then(reposition);
      }
    }
  };
  return [
    dates,
    chunks,
    longChunks,
    iChunks,
    refs,
    $theme,
    _events,
    _iEvents,
    _hiddenEvents,
    hiddenDays,
    theme,
    reposition,
    start,
    end,
    $_hiddenEvents,
    $hiddenDays,
    $_iEvents,
    $_events,
    day_binding
  ];
}
var Week = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$12, safe_not_equal, { dates: 0 });
  }
};
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let week;
  let current;
  week = new Week({ props: { dates: (
    /*dates*/
    ctx[10]
  ) } });
  return {
    c() {
      create_component(week.$$.fragment);
    },
    m(target, anchor) {
      mount_component(week, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const week_changes = {};
      if (dirty & /*weeks*/
      1) week_changes.dates = /*dates*/
      ctx2[10];
      week.$set(week_changes);
    },
    i(local) {
      if (current) return;
      transition_in(week.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(week.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(week, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*weeks*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*weeks*/
      1) {
        each_value = ensure_array_like(
          /*weeks*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let header;
  let t;
  let body;
  let current;
  header = new Header({});
  body = new Body({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      create_component(body.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      mount_component(body, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const body_changes = {};
      if (dirty & /*$$scope, weeks*/
      8193) {
        body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      body.$set(body_changes);
    },
    i(local) {
      if (current) return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(header, detaching);
      destroy_component(body, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $_viewDates;
  let $dayMaxEvents;
  let $_hiddenEvents;
  let $hiddenDays;
  let { _viewDates, _hiddenEvents, dayMaxEvents, hiddenDays } = getContext("state");
  component_subscribe($$self, _viewDates, (value) => $$invalidate(6, $_viewDates = value));
  component_subscribe($$self, _hiddenEvents, (value) => $$invalidate(9, $_hiddenEvents = value));
  component_subscribe($$self, dayMaxEvents, (value) => $$invalidate(7, $dayMaxEvents = value));
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(8, $hiddenDays = value));
  let weeks;
  let days2;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$hiddenDays, $dayMaxEvents, $_viewDates, days, weeks*/
    481) {
      {
        $$invalidate(0, weeks = []);
        $$invalidate(5, days2 = 7 - $hiddenDays.length);
        set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);
        for (let i = 0; i < $_viewDates.length / days2; ++i) {
          let dates = [];
          for (let j = 0; j < days2; ++j) {
            dates.push($_viewDates[i * days2 + j]);
          }
          weeks.push(dates);
        }
      }
    }
  };
  return [
    weeks,
    _viewDates,
    _hiddenEvents,
    dayMaxEvents,
    hiddenDays,
    days2,
    $_viewDates,
    $dayMaxEvents,
    $hiddenDays
  ];
}
var View = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var index = {
  createOptions(options) {
    options.dayMaxEvents = false;
    options.dayCellFormat = { day: "numeric" };
    options.dayPopoverFormat = { month: "long", day: "numeric", year: "numeric" };
    options.moreLinkContent = void 0;
    options.buttonText.dayGridMonth = "month";
    options.buttonText.close = "Close";
    options.theme.uniform = "ec-uniform";
    options.theme.dayFoot = "ec-day-foot";
    options.theme.popup = "ec-popup";
    options.view = "dayGridMonth";
    options.views.dayGridMonth = {
      buttonText: btnTextMonth,
      component: View,
      dayHeaderFormat: { weekday: "short" },
      dayHeaderAriaLabelFormat: { weekday: "long" },
      displayEventEnd: false,
      duration: { months: 1 },
      theme: themeView("ec-day-grid ec-month-view"),
      titleFormat: { year: "numeric", month: "long" }
    };
  },
  createStores(state) {
    state._days = days(state);
    state._intlDayCell = intl(state.locale, state.dayCellFormat);
    state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
    state._hiddenEvents = writable({});
    state._popupDate = writable(null);
    state._popupChunks = writable([]);
  }
};

// src/component/RepetitionTaskView.svelte
var import_owlelia8 = __toESM(require_dist());
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_if_block_13(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*tasks*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentTask, tasks, handleClickTask*/
      11) {
        each_value = ensure_array_like(
          /*tasks*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div;
  let t0_value = (
    /*task*/
    ctx[11].name + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*task*/
        ctx[11]
      )
    );
  }
  function keypress_handler() {
    return (
      /*keypress_handler*/
      ctx[10](
        /*task*/
        ctx[11]
      )
    );
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "nav-file-title");
      toggle_class(
        div,
        "is-active",
        /*currentTask*/
        ctx[1] && /*task*/
        ctx[11].name == /*currentTask*/
        ctx[1].name
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler),
          listen(div, "keypress", keypress_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tasks*/
      1 && t0_value !== (t0_value = /*task*/
      ctx[11].name + "")) set_data(t0, t0_value);
      if (dirty & /*currentTask, tasks*/
      3) {
        toggle_class(
          div,
          "is-active",
          /*currentTask*/
          ctx[1] && /*task*/
          ctx[11].name == /*currentTask*/
          ctx[1].name
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block3(ctx) {
  let div;
  let t_value = (
    /*currentTask*/
    ctx[1].name + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      set_style(div, "padding", "8px");
      set_style(div, "display", "flex");
      set_style(div, "justify-content", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentTask*/
      2 && t_value !== (t_value = /*currentTask*/
      ctx2[1].name + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment3(ctx) {
  let h3;
  let t1;
  let div0;
  let t2;
  let div1;
  let calendar;
  let t3;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*tasks*/
    ctx[0] && create_if_block_13(ctx)
  );
  calendar = new Calendar({
    props: {
      plugins: (
        /*plugins*/
        ctx[4]
      ),
      options: (
        /*options*/
        ctx[2]
      )
    }
  });
  let if_block1 = (
    /*currentTask*/
    ctx[1] && create_if_block3(ctx)
  );
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Recurring tasks";
      t1 = space();
      div0 = element("div");
      if (if_block0) if_block0.c();
      t2 = space();
      div1 = element("div");
      create_component(calendar.$$.fragment);
      t3 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      set_style(div0, "height", "calc(100% - 275px - 50px - 75px)");
      set_style(div0, "overflow", "scroll");
      set_style(div1, "display", "flex");
      set_style(div1, "justify-content", "center");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, div0, anchor);
      if (if_block0) if_block0.m(div0, null);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      mount_component(calendar, div1, null);
      insert(target, t3, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*tasks*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const calendar_changes = {};
      if (dirty & /*options*/
      4) calendar_changes.options = /*options*/
      ctx2[2];
      calendar.$set(calendar_changes);
      if (
        /*currentTask*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(calendar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(div0);
        detach(t2);
        detach(div1);
        detach(t3);
        detach(if_block1_anchor);
      }
      if (if_block0) if_block0.d();
      destroy_component(calendar);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let datesInFuture;
  let options;
  var _a2;
  let { taskService } = $$props;
  let { tasks } = $$props;
  let { holidays } = $$props;
  let currentTask;
  const handleClickTask = async (task2) => {
    $$invalidate(1, currentTask = task2);
  };
  let plugins = [index];
  const click_handler = (task2) => handleClickTask(task2);
  const keypress_handler = (task2) => handleClickTask(task2);
  $$self.$$set = ($$props2) => {
    if ("taskService" in $$props2) $$invalidate(5, taskService = $$props2.taskService);
    if ("tasks" in $$props2) $$invalidate(0, tasks = $$props2.tasks);
    if ("holidays" in $$props2) $$invalidate(6, holidays = $$props2.holidays);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tasks, currentTask*/
    3) {
      $: {
        if ((tasks === null || tasks === void 0 ? void 0 : tasks.length) && tasks.length > 0) {
          $$invalidate(1, currentTask = tasks.find((x) => x.name === (currentTask === null || currentTask === void 0 ? void 0 : currentTask.name)));
        }
      }
    }
    if ($$self.$$.dirty & /*currentTask, taskService, holidays*/
    98) {
      $: $$invalidate(8, datesInFuture = currentTask ? taskService.calcDatesInFuture(currentTask, holidays, 3) : void 0);
    }
    if ($$self.$$.dirty & /*holidays, _a, datesInFuture*/
    448) {
      $: $$invalidate(2, options = {
        view: "dayGridMonth",
        highlightedDates: $$invalidate(7, _a2 = holidays === null || holidays === void 0 ? void 0 : holidays.map((x) => x.displayDate)) !== null && _a2 !== void 0 ? _a2 : [],
        dayCellFormat: (date) => date.getDate().toString(),
        events: datesInFuture ? import_owlelia8.DateTime.today().toDate(import_owlelia8.DateTime.today().plusMonths(3)).map((x) => {
          const has = datesInFuture.some((d) => d.equals(x));
          return {
            start: x.date,
            end: x.date,
            title: has ? "o" : "x",
            backgroundColor: has ? "var(--silhouette-calendar-task-mark-on)" : "var(--silhouette-calendar-task-mark-off)"
          };
        }) : [],
        eventContent: (info) => info.event.title
      });
    }
  };
  return [
    tasks,
    currentTask,
    options,
    handleClickTask,
    plugins,
    taskService,
    holidays,
    _a2,
    datesInFuture,
    click_handler,
    keypress_handler
  ];
}
var RepetitionTaskView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { taskService: 5, tasks: 0, holidays: 6 });
  }
};
var RepetitionTaskView_default = RepetitionTaskView;

// src/ui/RepetitionTaskItemView.ts
var REPETITION_TASK_VIEW_TYPE = "repetition-task";
var RepetitionTaskItemView = class extends import_obsidian4.ItemView {
  constructor(leaf, taskService) {
    super(leaf);
    this.taskService = taskService;
  }
  getViewType() {
    return REPETITION_TASK_VIEW_TYPE;
  }
  getDisplayText() {
    return "Silhouette";
  }
  getIcon() {
    return "cloud-fog";
  }
  async onclose() {
    this.view.$destroy();
  }
  async onOpen() {
    this.view = new RepetitionTaskView_default({
      target: this.containerEl.children[1],
      props: {
        taskService: this.taskService
      }
    });
    await this.refreshData();
  }
  async refreshData() {
    const [tasks, taskError] = await this.taskService.loadRepetitionTasks().then((x) => x.unwrap());
    const [holidays, holidaysError] = (await this.taskService.loadHolidays()).unwrap();
    this.view.$set({
      tasks,
      holidays
    });
  }
};

// src/app/TimerServiceImpl.ts
var import_obsidian5 = require("obsidian");
var import_owlelia9 = __toESM(require_dist());

// src/utils/times.ts
var pad00 = (v) => String(v).padStart(2, "0");
function toHHmmss(seconds) {
  const hour = seconds / (60 * 60) | 0;
  const min = seconds % (60 * 60) / 60 | 0;
  const sec = seconds % 60;
  return `${pad00(hour)}:${pad00(min)}:${pad00(sec)}`;
}
function toDisplayFooter(seconds) {
  const hour = seconds / (60 * 60) | 0;
  const min = seconds % (60 * 60) / 60 | 0;
  return hour > 0 ? `${hour}\u6642\u9593${min}\u5206` : `${min}\u5206`;
}

// src/domain/vo/TimerStatus.ts
function unsafeMatch(str, pattern2) {
  return Array.from(str.matchAll(pattern2))[0].groups;
}
var pattern = {
  neverRecorded: /[-*] \[.] (?<name>.+)/g,
  recording: /[-*] \[.] (?<name>.+)`⏳`$/g,
  recorded: /[-*] \[.] (?<name>.+)`⏲️(?<time>\d\d:\d\d:\d\d)`$/g
};
function isLineRecording(line) {
  return Boolean(line.match(pattern.recording));
}
var TimerStatus;
((TimerStatus2) => {
  function fromLine(line) {
    if (!line) {
      return new NotTaskStatus();
    }
    if (!Boolean(line.match(pattern.neverRecorded))) {
      return new NotTaskStatus();
    }
    if (isLineRecording(line)) {
      return new RecordingStatus();
    } else if (Boolean(line.match(pattern.recorded))) {
      return new RecordedStatus();
    } else {
      return new NeverRecordedStatus();
    }
  }
  TimerStatus2.fromLine = fromLine;
})(TimerStatus || (TimerStatus = {}));
var NotTaskStatus = class {
  constructor() {
    this.name = "notTask";
  }
};
var NeverRecordedStatus = class {
  constructor() {
    this.name = "neverRecorded";
  }
  parse(line) {
    const { name } = unsafeMatch(line, pattern.neverRecorded);
    return { name };
  }
  getNextStatusLine(line) {
    return `${line} \`\u23F3\``;
  }
};
var RecordingStatus = class {
  constructor() {
    this.name = "recording";
  }
  parse(line) {
    const { name } = unsafeMatch(line, pattern.recording);
    return { name };
  }
  getNextStatusLine(line, timer) {
    return line.replace("`\u23F3`", `\`\u23F2\uFE0F${toHHmmss(timer.accumulatedSeconds)}\``);
  }
};
var RecordedStatus = class {
  constructor() {
    this.name = "recorded";
  }
  parse(line) {
    const { name, time } = unsafeMatch(line, pattern.recorded);
    const [hours, minutes, seconds] = time.split(":").map(Number);
    return { name, seconds: hours * 60 * 60 + minutes * 60 + seconds };
  }
  getNextStatusLine(line) {
    return line.replace(/`⏲️\d\d:\d\d:\d\d`/, "`\u23F3`");
  }
};

// src/utils/parser.ts
function parseMarkdownList(text2) {
  var _a2, _b, _c, _d;
  const result = Array.from(
    text2.matchAll(/^(?<prefix>[ \t\s]*([-*] (\[.] |)|))(?<content>.*)$/g)
  ).at(0);
  return {
    prefix: (_b = (_a2 = result == null ? void 0 : result.groups) == null ? void 0 : _a2.prefix) != null ? _b : "",
    content: (_d = (_c = result == null ? void 0 : result.groups) == null ? void 0 : _c.content) != null ? _d : ""
  };
}

// src/utils/strings.ts
function pickPatterns(str, pattern2) {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = Array.from(str.matchAll(pattern2))) == null ? void 0 : _a2[0]) == null ? void 0 : _b.groups) != null ? _c : {};
}

// src/app/TimerServiceImpl.ts
var TimerServiceImpl = class _TimerServiceImpl {
  constructor(appHelper, repository) {
    this.appHelper = appHelper;
    this.repository = repository;
  }
  static create(appHelper, repository) {
    return new _TimerServiceImpl(appHelper, repository);
  }
  terminate() {
    if (this.intervalHandler) {
      window.clearInterval(this.intervalHandler);
    }
  }
  setOnTimerHandler(handler, intervalMilliSec) {
    this.handleEvent = async () => {
      const timer = (await this.repository.loadTimer()).orNull();
      handler(timer);
    };
    this.handleEvent();
    this.intervalHandler = window.setInterval(
      () => this.handleEvent(),
      intervalMilliSec
    );
  }
  serRepository(repository) {
    this.repository = repository;
  }
  async getTimer() {
    return (await this.repository.loadTimer()).orThrow();
  }
  hasTimer() {
    return this.repository.hasTimer();
  }
  async hasNotTimer() {
    return !await this.hasTimer();
  }
  async execute(option) {
    const line = this.appHelper.getActiveLine() || "";
    const lineTimeStatus = TimerStatus.fromLine(line);
    if (lineTimeStatus.name === "notTask") {
      return;
    }
    switch (lineTimeStatus.name) {
      case "recording":
        if (await this.hasNotTimer()) {
          new import_obsidian5.Notice(
            "\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u304C\u306A\u3044\u305F\u3081\u3001\u30AB\u30FC\u30BD\u30EB\u914D\u4E0B\u306E\u30BF\u30B9\u30AF\u3092\u8A08\u6E2C\u6E08\u306B\u3067\u304D\u307E\u305B\u3093\u3002",
            0
          );
          return;
        }
        this.appHelper.replaceStringInActiveLine(
          lineTimeStatus.getNextStatusLine(
            line,
            (await this.getTimer()).stop(import_owlelia9.DateTime.now())
          )
        );
        await this.repository.clearTimer();
        break;
      case "neverRecorded":
        if (await this.hasTimer()) {
          new import_obsidian5.Notice(
            "\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u304C\u3042\u308B\u305F\u3081\u3001\u65B0\u305F\u306A\u30BF\u30B9\u30AF\u3092\u8A08\u6E2C\u958B\u59CB\u3067\u304D\u307E\u305B\u3093\u3002\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u3092\u601D\u3044\u51FA\u305B\u306A\u3044\u5834\u5408\u306F 'Force stop recording' \u30B3\u30DE\u30F3\u30C9\u3092\u5B9F\u884C\u3057\u3001\u5F37\u5236\u7684\u306B\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u3092\u8A08\u6E2C\u5B8C\u4E86\u3055\u305B\u3066\u304F\u3060\u3055\u3044\u3002",
            0
          );
          return;
        }
        await this.repository.saveTimer(
          Timer.of({
            name: lineTimeStatus.parse(line).name,
            startTime: import_owlelia9.DateTime.now(),
            accumulatedSeconds: 0
          })
        );
        this.appHelper.replaceStringInActiveLine(
          lineTimeStatus.getNextStatusLine(line)
        );
        if (option.openAfterRecording) {
          this.appHelper.openLinkInActiveLine({ leaf: "same-tab" });
        }
        break;
      case "recorded":
        if (await this.hasTimer()) {
          new import_obsidian5.Notice(
            "\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u304C\u3042\u308B\u305F\u3081\u3001\u65B0\u305F\u306A\u30BF\u30B9\u30AF\u3092\u8A08\u6E2C\u958B\u59CB\u3067\u304D\u307E\u305B\u3093\u3002\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u3092\u601D\u3044\u51FA\u305B\u306A\u3044\u5834\u5408\u306F 'Force stop recording' \u30B3\u30DE\u30F3\u30C9\u3092\u5B9F\u884C\u3057\u3001\u5F37\u5236\u7684\u306B\u8A08\u6E2C\u4E2D\u306E\u30BF\u30B9\u30AF\u3092\u8A08\u6E2C\u5B8C\u4E86\u3055\u305B\u3066\u304F\u3060\u3055\u3044\u3002",
            0
          );
          return;
        }
        const { name, seconds: accumulatedSeconds } = lineTimeStatus.parse(line);
        this.appHelper.replaceStringInActiveLine(
          lineTimeStatus.getNextStatusLine(line)
        );
        await this.repository.saveTimer(
          Timer.of({
            name,
            startTime: import_owlelia9.DateTime.now(),
            accumulatedSeconds
          })
        );
        if (option.openAfterRecording) {
          this.appHelper.openLinkInActiveLine({ leaf: "same-tab" });
        }
        break;
    }
    this.handleEvent();
  }
  async cycleBulletCheckbox(startNextTaskAutomatically) {
    if (!this.appHelper.cycleListCheckList()) {
      return;
    }
    if (!this.appHelper.isCheckedCurrentLineTask()) {
      return;
    }
    const line = this.appHelper.getActiveLine() || "";
    const lineTimeStatus = TimerStatus.fromLine(line);
    if (lineTimeStatus.name !== "recording") {
      return;
    }
    await this.execute({ openAfterRecording: false });
    if (!startNextTaskAutomatically) {
      return;
    }
    const nextLine = this.appHelper.getActiveNextLine() || "";
    const nextLineTimeStatus = TimerStatus.fromLine(nextLine);
    if (nextLineTimeStatus.name === "notTask") {
      return;
    }
    this.appHelper.moveNextLine();
    if (this.appHelper.isCheckedCurrentLineTask()) {
      return;
    }
    await this.execute({ openAfterRecording: false });
  }
  moveToRecording() {
    var _a2;
    const content = this.appHelper.getActiveFileContent();
    if (!content) {
      return;
    }
    const recordingLineIndex = content.split("\n").findIndex(isLineRecording);
    if (recordingLineIndex !== -1) {
      (_a2 = this.appHelper.getActiveMarkdownEditor()) == null ? void 0 : _a2.setCursor({ line: recordingLineIndex, ch: 0 });
    }
  }
  async forceStopRecording() {
    await this.repository.clearTimer();
  }
  insertCurrentTime() {
    var _a2;
    const activeLine = (_a2 = this.appHelper.getActiveLine()) != null ? _a2 : "";
    const { prefix, content } = parseMarkdownList(activeLine);
    const { startTime, contentWithoutTime } = pickPatterns(
      content,
      /^((?<startTime>\d{2}:\d{2}) |)(- (?<endTime>\d{2}:\d{2}) |)(?<contentWithoutTime>.+)/g
    );
    const now3 = import_owlelia9.DateTime.now().format("HH:mm");
    this.appHelper.replaceStringInActiveLine(
      startTime ? `${prefix}${startTime} - ${now3} ${contentWithoutTime != null ? contentWithoutTime : ""}` : `${prefix}${now3} ${contentWithoutTime != null ? contentWithoutTime : ""}`,
      { cursor: "last" }
    );
  }
};

// src/commands.ts
var import_obsidian6 = require("obsidian");
var import_owlelia10 = __toESM(require_dist());
function createCommands(appHelper, settings, taskService, timerService) {
  return [
    {
      id: "insert-tasks",
      name: "Insert tasks",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            const date = import_owlelia10.DateTime.from(
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              appHelper.getActiveFile().basename,
              settings.fileDateFormat || void 0
            );
            taskService.insertTasksToDailyNote(date).then((err2) => {
              if (err2) {
                new import_obsidian6.Notice(`[\u30A8\u30E9\u30FC] ${err2.name}

 ${err2.message}`, 0);
                return;
              }
              new import_obsidian6.Notice(
                `Insert tasks that should do on ${date.format("YYYY/MM/DD")}`
              );
            });
          }
          return true;
        }
      }
    },
    {
      id: "push-timer",
      name: "Push timer",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.execute({ openAfterRecording: false });
          }
          return true;
        }
      }
    },
    {
      id: "push-timer-and-open",
      name: "Push timer and open",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.execute({ openAfterRecording: true });
          }
          return true;
        }
      }
    },
    {
      id: "cycle-bullet-checkbox",
      name: "Cycle bullet/checkbox",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.cycleBulletCheckbox(
              settings.startNextTaskAutomaticallyAfterDone
            );
          }
          return true;
        }
      }
    },
    {
      id: "move-to-recording",
      name: "Move to recording",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.moveToRecording();
          }
          return true;
        }
      }
    },
    {
      id: "force-stop-recording",
      name: "Force stop recording",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.forceStopRecording();
          }
          return true;
        }
      }
    },
    {
      id: "insert-current-time",
      name: "Insert current time",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            timerService.insertCurrentTime();
          }
          return true;
        }
      }
    }
  ];
}

// src/main.ts
var import_owlelia11 = __toESM(require_dist());
var SilhouettePlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.commands = [];
  }
  async onload() {
    await this.loadSettings();
    this.appHelper = new AppHelper(this.app);
    this.taskService = new TaskServiceImpl(
      this.appHelper,
      new TaskRepositoryImpl(
        this.appHelper,
        this.settings.taskFilePath,
        this.settings.holidayFilePath
      )
    );
    this.timerService = TimerServiceImpl.create(
      this.appHelper,
      new TimerRepositoryImpl(
        this.appHelper,
        this.settings.timerStorageFilePath || `${this.manifest.dir}/timer.json`
      )
    );
    if (this.settings.showTimeOnStatusBar) {
      this.addStatusBar();
    }
    this.registerView(REPETITION_TASK_VIEW_TYPE, (leaf) => {
      this.repetitionTaskView = new RepetitionTaskItemView(
        leaf,
        this.taskService
      );
      if (this.fileEventRef) {
        this.app.vault.offref(this.fileEventRef);
      }
      this.fileEventRef = this.app.vault.on("modify", async (file) => {
        if (file.path === this.settings.taskFilePath || file.path === this.settings.holidayFilePath) {
          await this.repetitionTaskView.refreshData();
        }
      });
      return this.repetitionTaskView;
    });
    this.addRibbonIcon("cloud-fog", "Activate view", async () => {
      await this.activateView();
    });
    this.commands.forEach((x) => this.appHelper.removeCommand(x.id));
    this.commands = createCommands(
      this.appHelper,
      this.settings,
      this.taskService,
      this.timerService
    ).map((x) => this.addCommand(x));
    this.addSettingTab(new SilhouetteSettingTab(this.app, this));
  }
  async onunload() {
    this.timerService.terminate();
    if (this.fileEventRef) {
      this.app.vault.offref(this.fileEventRef);
    }
    this.app.workspace.detachLeavesOfType(REPETITION_TASK_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.reset();
  }
  addStatusBar() {
    this.timerStatusBar = this.addStatusBarItem();
    const timerStatusItem = this.timerStatusBar.createEl("span", {
      text: "\u672A\u6E2C\u5B9A",
      cls: "silhouette__footer silhouette__footer__timer"
    });
    this.timerService.setOnTimerHandler((timer) => {
      const timerText = timer ? toDisplayFooter(timer.getPastSeconds(import_owlelia11.DateTime.now())) : "\u672A\u6E2C\u5B9A";
      timerStatusItem.setText(timerText);
    }, 30 * 1e3);
  }
  async reset() {
    var _a2;
    this.taskService.serRepository(
      new TaskRepositoryImpl(
        this.appHelper,
        this.settings.taskFilePath,
        this.settings.holidayFilePath
      )
    );
    this.timerService.serRepository(
      new TimerRepositoryImpl(
        this.appHelper,
        this.settings.timerStorageFilePath || `${this.manifest.dir}/timer.json`
      )
    );
    this.timerService.terminate();
    (_a2 = this.timerStatusBar) == null ? void 0 : _a2.remove();
    if (this.settings.showTimeOnStatusBar) {
      this.addStatusBar();
    }
  }
  async activateView() {
    var _a2;
    this.app.workspace.detachLeavesOfType(REPETITION_TASK_VIEW_TYPE);
    await ((_a2 = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a2.setViewState({
      type: REPETITION_TASK_VIEW_TYPE,
      active: true
    }));
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(REPETITION_TASK_VIEW_TYPE)[0]
    );
  }
};
